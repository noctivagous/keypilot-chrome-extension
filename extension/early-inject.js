/**
 * Early injection script for KeyPilot - runs at document_start
 * Makes SVG cursor available immediately before page load
 */

(function() {
  'use strict';

  // Constants extracted from main extension for early injection
  const CURSOR_ID = 'kpv2-cursor';
  const STYLE_ID = 'kpv2-early-style';
  const FOCUS_GREEN_BRIGHT = 'rgba(0,128,0,0.95)';
  const KEYBOARD_HELP_STORAGE_KEY = 'keypilot_keyboard_help_visible';
  const ONBOARDING_ACTIVE_STORAGE_KEY = 'keypilot_onboarding_active';
  const ONBOARDING_PROGRESS_STORAGE_KEY = 'keypilot_onboarding_progress';
  const SETTINGS_STORAGE_KEY = 'kp_settings_v1';
  const Z_ONBOARDING_PANEL = 2147483017;
  const CURSOR_MODE = {
    NO_CUSTOM_CURSORS: 'NO-CUSTOM-CURSORS',
    CUSTOM_CURSORS: 'CUSTOM-CURSORS'
  };
  // Mirror the main extension's cursor mechanism so handoff is seamless.
  // See: `extension/src/modules/cursor.js` + `extension/src/modules/style-manager.js`
  const CURSOR_VAR = '--kpv2-cursor';
  const CURSOR_HIDDEN_CLASS = 'kpv2-cursor-hidden';
  // KP_EARLY_INJECT_UI_START
  // NOTE: This block is auto-generated by `extension/build.js` from:
  // - `extension/src/config/constants.js` (KEYBINDINGS, Z_INDEX)
  // - `extension/src/config/keyboard-layouts.js` (built-in layout data)
  // - `extension/src/ui/keybindings-ui-shared.js` (CSS + layout + style attr)
  // - `extension/pages/onboarding.xml` (early onboarding model)
  // Do not edit by hand.
  const Z_FLOATING_KEYBOARD_HELP = 1000000;
  const Z_KEYBINDINGS_POPOVER = 1000010;
  const KEYBINDINGS_UI_STYLE_ATTR = "data-kp-keybindings-ui-style";
  const DEFAULT_KEYBOARD_LAYOUT_ID = "browsing-right";
  const KEYBOARD_LAYOUTS_BY_ID = {
  "browsing-right": [
    [
      {
        "type": "special",
        "text": "Tab",
        "className": "key key-tab"
      },
      {
        "type": "action",
        "id": "TAB_LEFT",
        "fallbackText": "Tab Left"
      },
      {
        "type": "action",
        "id": "TAB_RIGHT",
        "fallbackText": "Tab Right"
      },
      {
        "type": "action",
        "id": "OPEN_POPOVER",
        "fallbackText": "Open Popover"
      },
      {
        "type": "action",
        "id": "FORWARD",
        "fallbackText": "Go Forward"
      },
      {
        "type": "action",
        "id": "NEW_TAB",
        "fallbackText": "New Tab"
      },
      {
        "type": "key",
        "text": "Y"
      },
      {
        "type": "key",
        "text": "U"
      },
      {
        "type": "key",
        "text": "I"
      },
      {
        "type": "key",
        "text": "O"
      },
      {
        "type": "key",
        "text": "P"
      },
      {
        "type": "key",
        "text": "["
      },
      {
        "type": "key",
        "text": "]"
      },
      {
        "type": "action",
        "id": "DELETE",
        "fallbackText": "Delete Mode",
        "className": "key key-backspace"
      }
    ],
    [
      {
        "type": "special",
        "text": "Caps",
        "className": "key key-caps"
      },
      {
        "type": "action",
        "id": "CLOSE_TAB",
        "fallbackText": "Close Tab"
      },
      {
        "type": "action",
        "id": "BACK2",
        "fallbackText": "Go Back"
      },
      {
        "type": "action",
        "id": "BACK",
        "fallbackText": "Go Back"
      },
      {
        "type": "action",
        "id": "ACTIVATE",
        "fallbackText": "Click Element"
      },
      {
        "type": "action",
        "id": "ACTIVATE_NEW_TAB",
        "fallbackText": "Click New Tab"
      },
      {
        "type": "key",
        "text": "H"
      },
      {
        "type": "action",
        "id": "TAB_HISTORY",
        "fallbackText": "History"
      },
      {
        "type": "action",
        "id": "TOGGLE_KEYBOARD_HELP",
        "fallbackText": "KB Reference"
      },
      {
        "type": "action",
        "id": "OMNIBOX",
        "fallbackText": "Omnibox"
      },
      {
        "type": "key",
        "text": ";"
      },
      {
        "type": "action",
        "id": "OPEN_SETTINGS_POPOVER",
        "fallbackText": "Settings"
      },
      {
        "type": "special",
        "text": "Enter",
        "className": "key key-enter"
      }
    ],
    [
      {
        "type": "special",
        "text": "Shift",
        "className": "key key-shift"
      },
      {
        "type": "action",
        "id": "PAGE_TOP",
        "fallbackText": "Scroll To Top"
      },
      {
        "type": "action",
        "id": "PAGE_BOTTOM",
        "fallbackText": "Scroll To Bottom"
      },
      {
        "type": "action",
        "id": "PAGE_UP_INSTANT",
        "fallbackText": "Page Up Fast"
      },
      {
        "type": "action",
        "id": "PAGE_DOWN_INSTANT",
        "fallbackText": "Page Down Fast"
      },
      {
        "type": "action",
        "id": "ACTIVATE_NEW_TAB_OVER",
        "fallbackText": "Click New Tab Over"
      },
      {
        "type": "key",
        "text": "N"
      },
      {
        "type": "key",
        "text": "M"
      },
      {
        "type": "key",
        "text": ","
      },
      {
        "type": "key",
        "text": "."
      },
      {
        "type": "key",
        "text": "/"
      },
      {
        "type": "special",
        "text": "Shift",
        "className": "key key-shift"
      }
    ]
  ],
  "browsing-left": [
    [
      {
        "type": "special",
        "text": "Tab",
        "className": "key key-tab"
      },
      {
        "type": "key",
        "text": "Q"
      },
      {
        "type": "key",
        "text": "W"
      },
      {
        "type": "key",
        "text": "E"
      },
      {
        "type": "key",
        "text": "R"
      },
      {
        "type": "key",
        "text": "T"
      },
      {
        "type": "action",
        "id": "NEW_TAB",
        "fallbackText": "New Tab"
      },
      {
        "type": "action",
        "id": "FORWARD",
        "fallbackText": "Go Forward"
      },
      {
        "type": "action",
        "id": "OPEN_POPOVER",
        "fallbackText": "Open Popover"
      },
      {
        "type": "action",
        "id": "TAB_RIGHT",
        "fallbackText": "Tab Right"
      },
      {
        "type": "action",
        "id": "TAB_LEFT",
        "fallbackText": "Tab Left"
      },
      {
        "type": "key",
        "text": "["
      },
      {
        "type": "key",
        "text": "]"
      },
      {
        "type": "action",
        "id": "DELETE",
        "fallbackText": "Delete Mode",
        "className": "key key-backspace"
      }
    ],
    [
      {
        "type": "special",
        "text": "Caps",
        "className": "key key-caps"
      },
      {
        "type": "key",
        "text": "A"
      },
      {
        "type": "action",
        "id": "OMNIBOX",
        "fallbackText": "Omnibox"
      },
      {
        "type": "action",
        "id": "TOGGLE_KEYBOARD_HELP",
        "fallbackText": "KB Reference"
      },
      {
        "type": "action",
        "id": "TAB_HISTORY",
        "fallbackText": "History"
      },
      {
        "type": "key",
        "text": "G"
      },
      {
        "type": "action",
        "id": "ACTIVATE_NEW_TAB",
        "fallbackText": "Click New Tab"
      },
      {
        "type": "action",
        "id": "ACTIVATE",
        "fallbackText": "Click Element"
      },
      {
        "type": "action",
        "id": "BACK",
        "fallbackText": "Go Back"
      },
      {
        "type": "action",
        "id": "BACK2",
        "fallbackText": "Go Back"
      },
      {
        "type": "action",
        "id": "CLOSE_TAB",
        "fallbackText": "Close Tab"
      },
      {
        "type": "action",
        "id": "OPEN_SETTINGS_POPOVER",
        "fallbackText": "Settings"
      },
      {
        "type": "special",
        "text": "Enter",
        "className": "key key-enter"
      }
    ],
    [
      {
        "type": "special",
        "text": "Shift",
        "className": "key key-shift"
      },
      {
        "type": "key",
        "text": "Z"
      },
      {
        "type": "key",
        "text": "X"
      },
      {
        "type": "key",
        "text": "C"
      },
      {
        "type": "key",
        "text": "V"
      },
      {
        "type": "key",
        "text": "B"
      },
      {
        "type": "action",
        "id": "ACTIVATE_NEW_TAB_OVER",
        "fallbackText": "Click New Tab Over"
      },
      {
        "type": "action",
        "id": "PAGE_DOWN_INSTANT",
        "fallbackText": "Page Down Fast"
      },
      {
        "type": "action",
        "id": "PAGE_UP_INSTANT",
        "fallbackText": "Page Up Fast"
      },
      {
        "type": "action",
        "id": "PAGE_BOTTOM",
        "fallbackText": "Scroll To Bottom"
      },
      {
        "type": "action",
        "id": "PAGE_TOP",
        "fallbackText": "Scroll To Top"
      },
      {
        "type": "special",
        "text": "Shift",
        "className": "key key-shift"
      }
    ]
  ]
};
  const EARLY_KEYBINDINGS_BY_ID = {
  "browsing-right": {
    "TAB_LEFT": {
      "label": "Tab Left",
      "description": "Move To Previous Tab",
      "keyLabel": "Q",
      "displayKey": "Q",
      "keyboardClass": "key-gray"
    },
    "TAB_RIGHT": {
      "label": "Tab Right",
      "description": "Move To Next Tab",
      "keyLabel": "W",
      "displayKey": "W",
      "keyboardClass": "key-gray"
    },
    "OPEN_POPOVER": {
      "label": "Open Popover",
      "description": "Open Link in Popover",
      "keyLabel": "E",
      "displayKey": "E",
      "keyboardClass": "key-open-popover"
    },
    "FORWARD": {
      "label": "Go Forward",
      "description": "Go Forward (History)",
      "keyLabel": "R",
      "displayKey": "R",
      "keyboardClass": "key-forward"
    },
    "NEW_TAB": {
      "label": "New Tab",
      "description": "Open New Tab",
      "keyLabel": "T",
      "displayKey": "T",
      "keyboardClass": "key-gray"
    },
    "DELETE": {
      "label": "Delete Mode",
      "description": "Delete Mode",
      "keyLabel": "Backspace",
      "displayKey": "Backspace",
      "keyboardClass": "key-delete"
    },
    "CLOSE_TAB": {
      "label": "Close Tab",
      "description": "Close Tab",
      "keyLabel": "A",
      "displayKey": "A",
      "keyboardClass": "key-close-tab"
    },
    "BACK2": {
      "label": "Go Back",
      "description": "Go Back (History)",
      "keyLabel": "S",
      "displayKey": "S",
      "keyboardClass": "key-back"
    },
    "BACK": {
      "label": "Go Back",
      "description": "Go Back (History)",
      "keyLabel": "D",
      "displayKey": "D",
      "keyboardClass": "key-back"
    },
    "ACTIVATE": {
      "label": "Click Element",
      "description": "Click Element",
      "keyLabel": "F",
      "displayKey": "F",
      "keyboardClass": "key-activate"
    },
    "ACTIVATE_NEW_TAB": {
      "label": "Click Tab Over",
      "description": "Open Link in New Tab (Background, like middle click)",
      "keyLabel": "G",
      "displayKey": "G",
      "keyboardClass": "key-activate-new-over"
    },
    "TAB_HISTORY": {
      "label": "Tab History",
      "description": "Open Tab History (Branch-Retaining)",
      "keyLabel": "J",
      "displayKey": "J",
      "keyboardClass": "key-gray"
    },
    "TOGGLE_KEYBOARD_HELP": {
      "label": "KB Reference",
      "description": "Show/Hide the floating KeyPilot keyboard reference",
      "keyLabel": "K",
      "displayKey": "K",
      "keyboardClass": "key-purple"
    },
    "OMNIBOX": {
      "label": "Omnibox",
      "description": "Open Omnibox (Address Bar Overlay)",
      "keyLabel": "L",
      "displayKey": "L",
      "keyboardClass": "key-orange"
    },
    "OPEN_SETTINGS_POPOVER": {
      "label": "Settings",
      "description": "Open KeyPilot Settings",
      "keyLabel": "'",
      "displayKey": "'",
      "keyboardClass": null
    },
    "PAGE_TOP": {
      "label": "Scroll To Top",
      "description": "Scroll to Top",
      "keyLabel": "Z",
      "displayKey": "Z",
      "keyboardClass": "key-scroll"
    },
    "PAGE_BOTTOM": {
      "label": "Scroll To Bottom",
      "description": "Scroll to Bottom",
      "keyLabel": "X",
      "displayKey": "X",
      "keyboardClass": "key-scroll"
    },
    "PAGE_UP_INSTANT": {
      "label": "Page Up Fast",
      "description": "Page Up (Instant)",
      "keyLabel": "C",
      "displayKey": "C",
      "keyboardClass": "key-scroll"
    },
    "PAGE_DOWN_INSTANT": {
      "label": "Page Down Fast",
      "description": "Page Down (Instant)",
      "keyLabel": "V",
      "displayKey": "V",
      "keyboardClass": "key-scroll"
    },
    "ACTIVATE_NEW_TAB_OVER": {
      "label": "Click New Tab",
      "description": "Click New Tab",
      "keyLabel": "B",
      "displayKey": "B",
      "keyboardClass": "key-activate-new"
    }
  },
  "browsing-left": {
    "TAB_LEFT": {
      "label": "Tab Left",
      "description": "Move To Previous Tab",
      "keyLabel": "P",
      "displayKey": "P",
      "keyboardClass": "key-gray"
    },
    "TAB_RIGHT": {
      "label": "Tab Right",
      "description": "Move To Next Tab",
      "keyLabel": "O",
      "displayKey": "O",
      "keyboardClass": "key-gray"
    },
    "OPEN_POPOVER": {
      "label": "Open Popover",
      "description": "Open Link in Popover",
      "keyLabel": "I",
      "displayKey": "I",
      "keyboardClass": "key-open-popover"
    },
    "FORWARD": {
      "label": "Go Forward",
      "description": "Go Forward (History)",
      "keyLabel": "U",
      "displayKey": "U",
      "keyboardClass": "key-forward"
    },
    "NEW_TAB": {
      "label": "New Tab",
      "description": "Open New Tab",
      "keyLabel": "Y",
      "displayKey": "Y",
      "keyboardClass": "key-gray"
    },
    "DELETE": {
      "label": "Delete Mode",
      "description": "Delete Mode",
      "keyLabel": "Backspace",
      "displayKey": "Backspace",
      "keyboardClass": "key-delete"
    },
    "CLOSE_TAB": {
      "label": "Close Tab",
      "description": "Close Tab",
      "keyLabel": ";",
      "displayKey": ";",
      "keyboardClass": "key-close-tab"
    },
    "BACK2": {
      "label": "Go Back",
      "description": "Go Back (History)",
      "keyLabel": "L",
      "displayKey": "L",
      "keyboardClass": "key-back"
    },
    "BACK": {
      "label": "Go Back",
      "description": "Go Back (History)",
      "keyLabel": "K",
      "displayKey": "K",
      "keyboardClass": "key-back"
    },
    "ACTIVATE": {
      "label": "Click Element",
      "description": "Click Element",
      "keyLabel": "J",
      "displayKey": "J",
      "keyboardClass": "key-activate"
    },
    "ACTIVATE_NEW_TAB": {
      "label": "Click Tab Over",
      "description": "Open Link in New Tab (Background, like middle click)",
      "keyLabel": "H",
      "displayKey": "H",
      "keyboardClass": "key-activate-new-over"
    },
    "TAB_HISTORY": {
      "label": "Tab History",
      "description": "Open Tab History (Branch-Retaining)",
      "keyLabel": "F",
      "displayKey": "F",
      "keyboardClass": "key-gray"
    },
    "TOGGLE_KEYBOARD_HELP": {
      "label": "KB Reference",
      "description": "Show/Hide the floating KeyPilot keyboard reference",
      "keyLabel": "D",
      "displayKey": "D",
      "keyboardClass": "key-purple"
    },
    "OMNIBOX": {
      "label": "Omnibox",
      "description": "Open Omnibox (Address Bar Overlay)",
      "keyLabel": "S",
      "displayKey": "S",
      "keyboardClass": "key-orange"
    },
    "OPEN_SETTINGS_POPOVER": {
      "label": "Settings",
      "description": "Open KeyPilot Settings",
      "keyLabel": "'",
      "displayKey": "'",
      "keyboardClass": null
    },
    "PAGE_TOP": {
      "label": "Scroll To Top",
      "description": "Scroll to Top",
      "keyLabel": "/",
      "displayKey": "/",
      "keyboardClass": "key-scroll"
    },
    "PAGE_BOTTOM": {
      "label": "Scroll To Bottom",
      "description": "Scroll to Bottom",
      "keyLabel": ".",
      "displayKey": ".",
      "keyboardClass": "key-scroll"
    },
    "PAGE_UP_INSTANT": {
      "label": "Page Up Fast",
      "description": "Page Up (Instant)",
      "keyLabel": ",",
      "displayKey": ",",
      "keyboardClass": "key-scroll"
    },
    "PAGE_DOWN_INSTANT": {
      "label": "Page Down Fast",
      "description": "Page Down (Instant)",
      "keyLabel": "M",
      "displayKey": "M",
      "keyboardClass": "key-scroll"
    },
    "ACTIVATE_NEW_TAB_OVER": {
      "label": "Click New Tab",
      "description": "Click New Tab",
      "keyLabel": "N",
      "displayKey": "N",
      "keyboardClass": "key-activate-new"
    }
  }
};
  const KEYBINDINGS_KEYBOARD_LAYOUT = [
  [
    {
      "type": "special",
      "text": "Tab",
      "className": "key key-tab"
    },
    {
      "type": "action",
      "id": "TAB_LEFT",
      "fallbackText": "Tab Left"
    },
    {
      "type": "action",
      "id": "TAB_RIGHT",
      "fallbackText": "Tab Right"
    },
    {
      "type": "action",
      "id": "OPEN_POPOVER",
      "fallbackText": "Open Popover"
    },
    {
      "type": "action",
      "id": "FORWARD",
      "fallbackText": "Go Forward"
    },
    {
      "type": "action",
      "id": "NEW_TAB",
      "fallbackText": "New Tab"
    },
    {
      "type": "key",
      "text": "Y"
    },
    {
      "type": "key",
      "text": "U"
    },
    {
      "type": "key",
      "text": "I"
    },
    {
      "type": "key",
      "text": "O"
    },
    {
      "type": "key",
      "text": "P"
    },
    {
      "type": "key",
      "text": "["
    },
    {
      "type": "key",
      "text": "]"
    },
    {
      "type": "action",
      "id": "DELETE",
      "fallbackText": "Delete Mode",
      "className": "key key-backspace"
    }
  ],
  [
    {
      "type": "special",
      "text": "Caps",
      "className": "key key-caps"
    },
    {
      "type": "action",
      "id": "CLOSE_TAB",
      "fallbackText": "Close Tab"
    },
    {
      "type": "action",
      "id": "BACK2",
      "fallbackText": "Go Back"
    },
    {
      "type": "action",
      "id": "BACK",
      "fallbackText": "Go Back"
    },
    {
      "type": "action",
      "id": "ACTIVATE",
      "fallbackText": "Click Element"
    },
    {
      "type": "action",
      "id": "ACTIVATE_NEW_TAB",
      "fallbackText": "Click New Tab"
    },
    {
      "type": "key",
      "text": "H"
    },
    {
      "type": "action",
      "id": "TAB_HISTORY",
      "fallbackText": "History"
    },
    {
      "type": "action",
      "id": "TOGGLE_KEYBOARD_HELP",
      "fallbackText": "KB Reference"
    },
    {
      "type": "action",
      "id": "OMNIBOX",
      "fallbackText": "Omnibox"
    },
    {
      "type": "key",
      "text": ";"
    },
    {
      "type": "action",
      "id": "OPEN_SETTINGS_POPOVER",
      "fallbackText": "Settings"
    },
    {
      "type": "special",
      "text": "Enter",
      "className": "key key-enter"
    }
  ],
  [
    {
      "type": "special",
      "text": "Shift",
      "className": "key key-shift"
    },
    {
      "type": "action",
      "id": "PAGE_TOP",
      "fallbackText": "Scroll To Top"
    },
    {
      "type": "action",
      "id": "PAGE_BOTTOM",
      "fallbackText": "Scroll To Bottom"
    },
    {
      "type": "action",
      "id": "PAGE_UP_INSTANT",
      "fallbackText": "Page Up Fast"
    },
    {
      "type": "action",
      "id": "PAGE_DOWN_INSTANT",
      "fallbackText": "Page Down Fast"
    },
    {
      "type": "action",
      "id": "ACTIVATE_NEW_TAB_OVER",
      "fallbackText": "Click New Tab Over"
    },
    {
      "type": "key",
      "text": "N"
    },
    {
      "type": "key",
      "text": "M"
    },
    {
      "type": "key",
      "text": ","
    },
    {
      "type": "key",
      "text": "."
    },
    {
      "type": "key",
      "text": "/"
    },
    {
      "type": "special",
      "text": "Shift",
      "className": "key key-shift"
    }
  ]
];
  const EARLY_KEYBINDINGS = {
  "TAB_LEFT": {
    "label": "Tab Left",
    "description": "Move To Previous Tab",
    "keyLabel": "Q",
    "displayKey": "Q",
    "keyboardClass": "key-gray"
  },
  "TAB_RIGHT": {
    "label": "Tab Right",
    "description": "Move To Next Tab",
    "keyLabel": "W",
    "displayKey": "W",
    "keyboardClass": "key-gray"
  },
  "OPEN_POPOVER": {
    "label": "Open Popover",
    "description": "Open Link in Popover",
    "keyLabel": "E",
    "displayKey": "E",
    "keyboardClass": "key-open-popover"
  },
  "FORWARD": {
    "label": "Go Forward",
    "description": "Go Forward (History)",
    "keyLabel": "R",
    "displayKey": "R",
    "keyboardClass": "key-forward"
  },
  "NEW_TAB": {
    "label": "New Tab",
    "description": "Open New Tab",
    "keyLabel": "T",
    "displayKey": "T",
    "keyboardClass": "key-gray"
  },
  "DELETE": {
    "label": "Delete Mode",
    "description": "Delete Mode",
    "keyLabel": "Backspace",
    "displayKey": "Backspace",
    "keyboardClass": "key-delete"
  },
  "CLOSE_TAB": {
    "label": "Close Tab",
    "description": "Close Tab",
    "keyLabel": "A",
    "displayKey": "A",
    "keyboardClass": "key-close-tab"
  },
  "BACK2": {
    "label": "Go Back",
    "description": "Go Back (History)",
    "keyLabel": "S",
    "displayKey": "S",
    "keyboardClass": "key-back"
  },
  "BACK": {
    "label": "Go Back",
    "description": "Go Back (History)",
    "keyLabel": "D",
    "displayKey": "D",
    "keyboardClass": "key-back"
  },
  "ACTIVATE": {
    "label": "Click Element",
    "description": "Click Element",
    "keyLabel": "F",
    "displayKey": "F",
    "keyboardClass": "key-activate"
  },
  "ACTIVATE_NEW_TAB": {
    "label": "Click Tab Over",
    "description": "Open Link in New Tab (Background, like middle click)",
    "keyLabel": "G",
    "displayKey": "G",
    "keyboardClass": "key-activate-new-over"
  },
  "TAB_HISTORY": {
    "label": "Tab History",
    "description": "Open Tab History (Branch-Retaining)",
    "keyLabel": "J",
    "displayKey": "J",
    "keyboardClass": "key-gray"
  },
  "TOGGLE_KEYBOARD_HELP": {
    "label": "KB Reference",
    "description": "Show/Hide the floating KeyPilot keyboard reference",
    "keyLabel": "K",
    "displayKey": "K",
    "keyboardClass": "key-purple"
  },
  "OMNIBOX": {
    "label": "Omnibox",
    "description": "Open Omnibox (Address Bar Overlay)",
    "keyLabel": "L",
    "displayKey": "L",
    "keyboardClass": "key-orange"
  },
  "OPEN_SETTINGS_POPOVER": {
    "label": "Settings",
    "description": "Open KeyPilot Settings",
    "keyLabel": "'",
    "displayKey": "'",
    "keyboardClass": null
  },
  "PAGE_TOP": {
    "label": "Scroll To Top",
    "description": "Scroll to Top",
    "keyLabel": "Z",
    "displayKey": "Z",
    "keyboardClass": "key-scroll"
  },
  "PAGE_BOTTOM": {
    "label": "Scroll To Bottom",
    "description": "Scroll to Bottom",
    "keyLabel": "X",
    "displayKey": "X",
    "keyboardClass": "key-scroll"
  },
  "PAGE_UP_INSTANT": {
    "label": "Page Up Fast",
    "description": "Page Up (Instant)",
    "keyLabel": "C",
    "displayKey": "C",
    "keyboardClass": "key-scroll"
  },
  "PAGE_DOWN_INSTANT": {
    "label": "Page Down Fast",
    "description": "Page Down (Instant)",
    "keyLabel": "V",
    "displayKey": "V",
    "keyboardClass": "key-scroll"
  },
  "ACTIVATE_NEW_TAB_OVER": {
    "label": "Click New Tab",
    "description": "Click New Tab",
    "keyLabel": "B",
    "displayKey": "B",
    "keyboardClass": "key-activate-new"
  }
};
  const EARLY_ONBOARDING_MODEL = {
  "slides": [
    {
      "id": "basic_navigation",
      "title": "Welcome to KeyPilot",
      "tasks": [
        {
          "id": "click_link",
          "label": "Hover over a link and press the `F` key to click it.",
          "when": {
            "type": "action",
            "action": "activate",
            "target": "link",
            "mode": "",
            "change": ""
          }
        },
        {
          "id": "go_back",
          "label": "To go back (history), press the `D` key.",
          "when": {
            "type": "action",
            "action": "back",
            "target": "",
            "mode": "",
            "change": ""
          }
        },
        {
          "id": "keyboard_key_info",
          "label": "Notice the Keyboard Reference window below. While hovering over a key, press the `F` key  \n    to find out what it does.",
          "when": {
            "type": "action",
            "action": "activate",
            "target": "keyboardHelpKey",
            "mode": "",
            "change": ""
          }
        },
        {
          "id": "toggle_extension",
          "label": "Press `Alt` + `K` to turn KeyPilot completely off. Press `Alt` + `K` again to turn it back on.",
          "when": {
            "type": "action",
            "action": "toggleExtension",
            "target": "",
            "mode": "",
            "change": ""
          }
        }
      ],
      "onEnter": []
    },
    {
      "id": "text_box_mode",
      "title": "Text box mode",
      "tasks": [
        {
          "id": "enter_text_mode",
          "label": "Focus a text field to enter text mode.",
          "when": {
            "type": "mode",
            "action": "",
            "target": "",
            "mode": "text_focus",
            "change": "enter"
          }
        },
        {
          "id": "exit_text_mode",
          "label": "Press `Escape` to exit text mode.",
          "when": {
            "type": "mode",
            "action": "",
            "target": "",
            "mode": "text_focus",
            "change": "exit"
          }
        }
      ],
      "onEnter": []
    },
    {
      "id": "scrolling",
      "title": "Scrolling the page",
      "tasks": [
        {
          "id": "scroll_down",
          "label": "Scroll down with `V`.",
          "when": {
            "type": "action",
            "action": "scrollDown",
            "target": "",
            "mode": "",
            "change": ""
          }
        },
        {
          "id": "scroll_up",
          "label": "Scroll up with `C`.",
          "when": {
            "type": "action",
            "action": "scrollUp",
            "target": "",
            "mode": "",
            "change": ""
          }
        },
        {
          "id": "scroll_top",
          "label": "Go to the top of the page with `Z`.",
          "when": {
            "type": "action",
            "action": "scrollTop",
            "target": "",
            "mode": "",
            "change": ""
          }
        },
        {
          "id": "scroll_bottom",
          "label": "Go to the bottom of the page with `X`.",
          "when": {
            "type": "action",
            "action": "scrollBottom",
            "target": "",
            "mode": "",
            "change": ""
          }
        }
      ],
      "onEnter": []
    },
    {
      "id": "tabs",
      "title": "Tabs",
      "tasks": [
        {
          "id": "open_link_new_tab",
          "label": "Click a link into a new tab (`B`).",
          "when": {
            "type": "action",
            "action": "activateNewTab",
            "target": "link",
            "mode": "",
            "change": ""
          }
        },
        {
          "id": "open_link_background_tab",
          "label": "Click a link into a new tab but don't open it (`G`).",
          "when": {
            "type": "action",
            "action": "activateNewTabBackground",
            "target": "link",
            "mode": "",
            "change": ""
          }
        },
        {
          "id": "open_new_tab",
          "label": "Open a new tab (`T`).",
          "when": {
            "type": "action",
            "action": "newTab",
            "target": "",
            "mode": "",
            "change": ""
          }
        },
        {
          "id": "move_tabs",
          "label": "Move between tabs (`Q` and `W`).",
          "when": {
            "type": "action",
            "action": "tabLeft",
            "target": "",
            "mode": "",
            "change": ""
          }
        },
        {
          "id": "move_tabs_2",
          "label": "Move between tabs (`Q` and `W`).",
          "when": {
            "type": "action",
            "action": "tabRight",
            "target": "",
            "mode": "",
            "change": ""
          }
        }
      ],
      "onEnter": []
    }
  ]
};
  const POPUP_THEME_VARS = {
  "--fg": "#f8fafc",
  "--bg": "#0f172a",
  "--surface": "#1e293b",
  "--surface-light": "#334155",
  "--muted": "#94a3b8",
  "--ok": "#10b981",
  "--warn": "#f59e0b",
  "--err": "#44c7ef",
  "--brand": "#3b82f6",
  "--brand-dark": "#1e40af",
  "--border": "#334155",
  "--border2": "#4d617b"
};
  function applyPopupThemeVars(targetEl) {
    if (!targetEl || !targetEl.style) return;
    try {
      for (const [k, v] of Object.entries(POPUP_THEME_VARS)) {
        targetEl.style.setProperty(k, v);
      }
    } catch { /* ignore */ }
  }
  const KEYBINDINGS_UI_EARLY_CSS = `
/* KeyPilot Keybindings UI (injected) */
@font-face {
  font-family: "ROBOTECHGPRegular";
  src: url("__KP_FONT_ROBOTECH_URL__") format("truetype");
  font-weight: normal;
  font-style: normal;
  font-display: swap;
}

@font-face {
  font-family: "TitilliumText";
  src: url("__KP_FONT_TITILLIUM_URL__") format("opentype");
  font-weight: normal;
  font-style: normal;
  font-display: swap;
}

@font-face {
  font-family: "Cubellan";
  src: url("__KP_FONT_CUBELLAN_URL__") format("truetype");
  font-weight: normal;
  font-style: normal;
  font-display: swap;
}

@font-face {
  font-family: "Ezarion";
  src: url("__KP_FONT_EZARION_URL__") format("truetype");
  font-weight: normal;
  font-style: normal;
  font-display: swap;
}

@font-face {
  font-family: "Dosis";
  src: url("__KP_FONT_DOSIS_URL__") format("truetype");
  font-weight: normal;
  font-style: normal;
  font-display: swap;
}

/* Style isolation: all keyboard rules are scoped so host page CSS won't override them */
.kp-keybindings-ui {
  --kp-accent: #5be2f1;
}

.keyboard-visual.kp-keybindings-ui {
  background: var(--bg, #0f172a);
  border-radius: 12px;
  padding: 14px;
  font-family: "Dosis", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  font-size: 10px;
  line-height: 1.1;
  user-select: none;
  border: 1px solid var(--border, #334155);
  width: 100%;
  box-sizing: border-box;
}

.kp-keybindings-ui .keyboard-row {
  display: flex;
  justify-content: center;
  margin-bottom: 8px;
  gap: 6px;
  width: 100%;
}

.kp-keybindings-ui .keyboard-row:last-child {
  margin-bottom: 0;
}

.kp-keybindings-ui .key {
  position: relative;
  /* Reset button default styles */
  margin: 0;
  font-family: inherit;
  font-size: inherit;
  line-height: inherit;
  cursor: pointer;
  /* End button reset */
  background: linear-gradient(180deg,
    rgba(45, 55, 72, 0.95) 0%,
    rgba(26, 32, 44, 0.95) 50%,
    rgba(15, 20, 30, 0.95) 100%);
  border: 1px solid rgba(255, 255, 255, 0.15);
  border-top: 1.5px solid rgba(255, 255, 255, 0.25);
  border-bottom: 1.5px solid rgba(0, 0, 0, 0.6);
  border-radius: 6px;
  min-width: 32px;
  /* Keep keys closer to square in narrow containers (popup, floating panel). */
  min-height: 38px;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  color: var(--fg, #f8fafc);
  text-align: center;
  padding: 4px;
  transition: all 0.2s ease;
  flex: 1;
  box-shadow:
    0 4px 6px rgba(0, 0, 0, 0.4),
    0 1px 3px rgba(0, 0, 0, 0.6),
    inset 0 1px 1px rgba(255, 255, 255, 0.1),
    inset 0 -2px 4px rgba(0, 0, 0, 0.3);
}

.kp-keybindings-ui .key::before {
  content: '';
  position: absolute;
  top: 1px;
  left: 1px;
  right: 1px;
  height: 30%;
  background: linear-gradient(180deg, rgba(255, 255, 255, 0.08) 0%, transparent 100%);
  border-radius: 5px 5px 0 0;
  pointer-events: none;
}

.kp-keybindings-ui [data-kp-action-id] {
  cursor: pointer;
}

.kp-keybindings-ui [data-kp-action-id]:hover {
  transform: translateY(-2px);
  box-shadow:
    0 6px 8px rgba(0, 0, 0, 0.4),
    0 2px 4px rgba(0, 0, 0, 0.6),
    inset 0 1px 2px rgba(255, 255, 255, 0.15),
    inset 0 -2px 4px rgba(0, 0, 0, 0.3);
}

.kp-keybindings-ui .key .key-main {
  font-size: 8px;
  opacity: 0.7;
  margin-bottom: 2px;
  text-transform: uppercase;
}

.kp-keybindings-ui .key .key-label {
  font-size: 12px;
  font-weight: 700;
  color: var(--kp-accent);
  line-height: 1;
}

/* Special keys: keep them wider than normal, but not so wide that letter keys become skinny in the popup */
.kp-keybindings-ui .key.key-tab { flex: 1.25; }
.kp-keybindings-ui .key.key-caps { flex: 1.35; }
.kp-keybindings-ui .key.key-enter { flex: 1.55; }
.kp-keybindings-ui .key.key-shift { flex: 1.65; }
.kp-keybindings-ui .key.key-backspace { flex: 1.55; }

/* Action-specific keys */
.kp-keybindings-ui .key.key-activate,
.kp-keybindings-ui .key.key-activate-new,
.kp-keybindings-ui .key.key-activate-new-over,
.kp-keybindings-ui .key.key-tab-right,
.kp-keybindings-ui .key.key-new-tab,
.kp-keybindings-ui .key.key-open-popover,
.kp-keybindings-ui .key.key-page-up,
.kp-keybindings-ui .key.key-page-down,
.kp-keybindings-ui .key.key-page-up-instant,
.kp-keybindings-ui .key.key-page-down-instant,
.kp-keybindings-ui .key.key-help,
.kp-keybindings-ui .key.key-omnibox {
  background: linear-gradient(180deg,
    rgba(34, 197, 94, 0.5) 0%,
    rgba(22, 163, 74, 0.6) 50%,
    rgba(21, 128, 61, 0.7) 100%);
  border-color: rgba(5, 150, 105, 0.6);
  border-top-color: rgba(34, 197, 94, 0.4);
  border-bottom-color: rgba(21, 128, 61, 0.8);
  box-shadow:
    0 4px 6px rgba(0, 0, 0, 0.4),
    0 1px 3px rgba(0, 0, 0, 0.6),
    inset 0 1px 1px rgba(34, 197, 94, 0.2),
    inset 0 -2px 4px rgba(0, 0, 0, 0.3),
    0 0 8px rgba(34, 197, 94, 0.15);
}

.kp-keybindings-ui .key.key-back,
.kp-keybindings-ui .key.key-forward,
.kp-keybindings-ui .key.key-scroll-top,
.kp-keybindings-ui .key.key-scroll-bottom {
  background: linear-gradient(180deg,
    rgba(56, 189, 248, 0.5) 0%,
    rgba(14, 165, 233, 0.6) 50%,
    rgba(2, 132, 199, 0.7) 100%);
  border-color: rgba(4, 177, 225, 0.6);
  border-top-color: rgba(56, 189, 248, 0.4);
  border-bottom-color: rgba(2, 132, 199, 0.8);
  box-shadow:
    0 4px 6px rgba(0, 0, 0, 0.4),
    0 1px 3px rgba(0, 0, 0, 0.6),
    inset 0 1px 1px rgba(56, 189, 248, 0.2),
    inset 0 -2px 4px rgba(0, 0, 0, 0.3),
    0 0 8px rgba(56, 189, 248, 0.15);
}

.kp-keybindings-ui .key.key-delete,
.kp-keybindings-ui .key.key-close-tab {
  background: linear-gradient(180deg,
    rgba(248, 113, 113, 0.5) 0%,
    rgba(239, 68, 68, 0.6) 50%,
    rgba(220, 38, 38, 0.7) 100%);
  border-color: rgba(220, 38, 38, 0.6);
  border-top-color: rgba(248, 113, 113, 0.4);
  border-bottom-color: rgba(220, 38, 38, 0.8);
  box-shadow:
    0 4px 6px rgba(0, 0, 0, 0.4),
    0 1px 3px rgba(0, 0, 0, 0.6),
    inset 0 1px 1px rgba(248, 113, 113, 0.2),
    inset 0 -2px 4px rgba(0, 0, 0, 0.3),
    0 0 8px rgba(248, 113, 113, 0.15);
}

.kp-keybindings-ui .key.key-highlight,
.kp-keybindings-ui .key.key-rect-highlight {
  background: linear-gradient(180deg,
    rgba(245, 158, 11, 0.5) 0%,
    rgba(217, 119, 6, 0.6) 50%,
    rgba(180, 83, 9, 0.7) 100%);
  border-color: rgba(245, 158, 11, 0.6);
  border-top-color: rgba(245, 158, 11, 0.4);
  border-bottom-color: rgba(180, 83, 9, 0.8);
}

.kp-keybindings-ui .key.key-scroll {
  background: linear-gradient(180deg,
    rgba(139, 69, 19, 0.5) 0%,
    rgba(101, 67, 33, 0.6) 50%,
    rgba(92, 64, 35, 0.7) 100%);
  border-color: rgba(139, 69, 19, 0.6);
  border-top-color: rgba(139, 69, 19, 0.4);
  border-bottom-color: rgba(92, 64, 35, 0.8);
  box-shadow:
    0 4px 6px rgba(0, 0, 0, 0.4),
    0 1px 3px rgba(0, 0, 0, 0.6),
    inset 0 1px 1px rgba(139, 69, 19, 0.2),
    inset 0 -2px 4px rgba(0, 0, 0, 0.3),
    0 0 8px rgba(139, 69, 19, 0.15);
}

.kp-keybindings-ui .key.key-purple {
  background: linear-gradient(180deg,
    rgba(147, 51, 234, 0.5) 0%,
    rgba(124, 58, 237, 0.6) 50%,
    rgba(88, 28, 135, 0.7) 100%);
  border-color: rgba(147, 51, 234, 0.6);
  border-top-color: rgba(147, 51, 234, 0.4);
  border-bottom-color: rgba(88, 28, 135, 0.8);
  box-shadow:
    0 4px 6px rgba(0, 0, 0, 0.4),
    0 1px 3px rgba(0, 0, 0, 0.6),
    inset 0 1px 1px rgba(147, 51, 234, 0.2),
    inset 0 -2px 4px rgba(0, 0, 0, 0.3),
    0 0 8px rgba(147, 51, 234, 0.15);
}

.kp-keybindings-ui .key.key-orange {
  background: linear-gradient(180deg,
    rgba(255, 165, 0, 0.5) 0%,
    rgba(255, 140, 0, 0.6) 50%,
    rgba(255, 69, 0, 0.7) 100%);
  border-color: rgba(255, 165, 0, 0.6);
  border-top-color: rgba(255, 165, 0, 0.4);
  border-bottom-color: rgba(255, 69, 0, 0.8);
  box-shadow:
    0 4px 6px rgba(0, 0, 0, 0.4),
    0 1px 3px rgba(0, 0, 0, 0.6),
    inset 0 1px 1px rgba(255, 165, 0, 0.2),
    inset 0 -2px 4px rgba(0, 0, 0, 0.3),
    0 0 8px rgba(255, 165, 0, 0.15);
}

.kp-keybindings-ui .key.key-gray {
  background: linear-gradient(180deg,
    rgba(128, 128, 128, 0.5) 0%,
    rgba(105, 105, 105, 0.6) 50%,
    rgba(85, 85, 85, 0.7) 100%);
  border-color: rgba(128, 128, 128, 0.6);
  border-top-color: rgba(128, 128, 128, 0.4);
  border-bottom-color: rgba(85, 85, 85, 0.8);
  box-shadow:
    0 4px 6px rgba(0, 0, 0, 0.4),
    0 1px 3px rgba(0, 0, 0, 0.6),
    inset 0 1px 1px rgba(128, 128, 128, 0.2),
    inset 0 -2px 4px rgba(0, 0, 0, 0.3),
    0 0 8px rgba(128, 128, 128, 0.15);
}
  border-top-color: rgba(255, 165, 0, 0.4);
  border-bottom-color: rgba(255, 69, 0, 0.8);
  box-shadow:
    0 4px 6px rgba(0, 0, 0, 0.4),
    0 1px 3px rgba(0, 0, 0, 0.6),
    inset 0 1px 1px rgba(255, 165, 0, 0.2),
    inset 0 -2px 4px rgba(0, 0, 0, 0.3),
    0 0 8px rgba(255, 165, 0, 0.15);
}

.kp-keybindings-ui .key.key-hatched {
  position: relative;
}

.kp-keybindings-ui .key.key-hatched::after {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-image:
    repeating-linear-gradient(
      45deg,
      rgba(200, 200, 200, 0.4) 0px,
      rgba(200, 200, 200, 0.4) 1px,
      transparent 1px,
      transparent 4px
    );
  pointer-events: none;
  border-radius: 4px;
}

.kp-keybindings-ui .key.key-radial-overlay::after {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: radial-gradient(circle at center,
    rgba(150, 150, 150, 0.3) 0%,
    rgba(120, 120, 120, 0.25) 30%,
    transparent 70%);
  pointer-events: none;
  border-radius: 4px;
}

.kp-keybindings-ui .key.key-checkerboard-overlay::after {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-image:
    radial-gradient(circle at 25% 25%, rgba(160, 160, 160, 0.3) 2px, transparent 2px),
    radial-gradient(circle at 75% 75%, rgba(160, 160, 160, 0.3) 2px, transparent 2px);
  background-size: 8px 8px;
  pointer-events: none;
  border-radius: 4px;
}

.kp-keybindings-ui .key.key-stripes-overlay::after {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-image:
    linear-gradient(90deg, transparent 0%, transparent 40%, rgba(180, 180, 180, 0.25) 40%, rgba(180, 180, 180, 0.25) 60%, transparent 60%);
  background-size: 6px 100%;
  pointer-events: none;
  border-radius: 4px;
}

.kp-keybindings-ui .key.key-crosshatch-overlay::after {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-image:
    repeating-linear-gradient(45deg, rgba(170, 170, 170, 0.25) 0px, rgba(170, 170, 170, 0.25) 1px, transparent 1px, transparent 4px),
    repeating-linear-gradient(-45deg, rgba(170, 170, 170, 0.25) 0px, rgba(170, 170, 170, 0.25) 1px, transparent 1px, transparent 4px);
  pointer-events: none;
  border-radius: 4px;
}

.kp-keybindings-ui .key.key-noise-overlay::after {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background:
    linear-gradient(45deg, rgba(80, 80, 80, 0.2) 25%, transparent 25%),
    linear-gradient(-45deg, rgba(80, 80, 80, 0.2) 25%, transparent 25%),
    linear-gradient(45deg, transparent 75%, rgba(80, 80, 80, 0.2) 75%),
    linear-gradient(-45deg, transparent 75%, rgba(80, 80, 80, 0.2) 75%);
  background-size: 4px 4px;
  pointer-events: none;
  border-radius: 4px;
}

.kp-keybindings-ui .key.key-conic-overlay::after {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: conic-gradient(
    from 45deg,
    rgba(100, 100, 100, 0.2) 0deg,
    rgba(120, 120, 120, 0.25) 90deg,
    rgba(140, 140, 140, 0.2) 180deg,
    rgba(100, 100, 100, 0.2) 360deg
  );
  pointer-events: none;
  border-radius: 4px;
}

.kp-keybindings-ui .key.key-dashed-overlay::after {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  box-shadow: inset 0 0 0 2px rgba(140, 140, 140, 0.4);
  pointer-events: none;
  border-radius: 4px;
}

/* Keydown/keyup feedback (used by the floating keyboard reference panel).
   Keep this AFTER action-specific key styles so it always wins the cascade. */
.kp-keybindings-ui .key.kp-key-pressed {
  transform: translateY(1px);
  outline: 2px solid rgba(91, 226, 241, 0.65);
  outline-offset: -2px;
  box-shadow:
    0 2px 4px rgba(0, 0, 0, 0.45),
    0 1px 2px rgba(0, 0, 0, 0.7),
    inset 0 0 0 2px rgba(91, 226, 241, 0.22),
    inset 0 -2px 4px rgba(0, 0, 0, 0.35),
    0 0 12px rgba(91, 226, 241, 0.28);
  filter: brightness(1.12) saturate(1.18);
}

/* Popover (tooltip) shown when clicking a key */
.kp-keybindings-popover {
  position: absolute;
  z-index: 1000010;
  max-width: 280px;
  background: var(--surface);
  color: var(--fg);
  border: 1px solid var(--border);
  border-radius: 10px;
  box-shadow: 0 12px 28px rgba(0, 0, 0, 0.45);
  padding: 10px 12px;
  font-size: 12px;
  line-height: 1.35;
  /* Position absolute relative to parent container avoids z-index stacking context issues */
}

.kp-keybindings-popover[hidden] { display: none; }

.kp-keybindings-popover .kp-popover-title {
  font-weight: 700;
  margin: 0 0 4px 0;
  color: var(--fg);
}

.kp-keybindings-popover .kp-popover-keys {
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  color: var(--muted);
  margin: 0 0 6px 0;
  font-size: 11px;
}

.kp-keybindings-popover .kp-popover-desc {
  margin: 0;
  color: var(--fg);
  opacity: 0.95;
}

.kp-keybindings-popover::before {
  content: "";
  position: absolute;
  width: 0;
  height: 0;
  left: var(--kp-arrow-left, 18px);
  border: 9px solid transparent;
}

.kp-keybindings-popover[data-placement="top"]::before {
  top: 100%;
  border-top-color: var(--border);
}

.kp-keybindings-popover[data-placement="top"]::after {
  content: "";
  position: absolute;
  width: 0;
  height: 0;
  left: var(--kp-arrow-left, 18px);
  top: calc(100% - 1px);
  border: 8px solid transparent;
  border-top-color: var(--surface);
}

.kp-keybindings-popover[data-placement="bottom"]::before {
  bottom: 100%;
  border-bottom-color: var(--border);
}

.kp-keybindings-popover[data-placement="bottom"]::after {
  content: "";
  position: absolute;
  width: 0;
  height: 0;
  left: var(--kp-arrow-left, 18px);
  bottom: calc(100% - 1px);
  border: 8px solid transparent;
  border-bottom-color: var(--surface);
}
`;
// KP_EARLY_INJECT_UI_END

  // Essential CSS for early injection - no longer needed for cursor element
  // Important: we intentionally mirror the main extension's cursor CSS contract:
  // - When `html` has `kpv2-cursor-hidden`, we force the cursor via `--kpv2-cursor`.
  // This prevents the "cursor pop-in" that used to happen at document_idle.
  const EARLY_CSS = `
    /* KeyPilot early cursor (document_start) */
    html.${CURSOR_HIDDEN_CLASS} * {
      cursor: var(${CURSOR_VAR}, auto) !important;
    }

    /* Ensure cursor overrides work on common interactive elements */
    html.${CURSOR_HIDDEN_CLASS} a[href],
    html.${CURSOR_HIDDEN_CLASS} button,
    html.${CURSOR_HIDDEN_CLASS} input,
    html.${CURSOR_HIDDEN_CLASS} select,
    html.${CURSOR_HIDDEN_CLASS} textarea,
    html.${CURSOR_HIDDEN_CLASS} [role="button"],
    html.${CURSOR_HIDDEN_CLASS} [role="link"],
    html.${CURSOR_HIDDEN_CLASS} [onclick],
    html.${CURSOR_HIDDEN_CLASS} [tabindex] {
      cursor: var(${CURSOR_VAR}, auto) !important;
    }
  `;

  // Early cursor state
  let isExtensionEnabled = true;
  let currentMode = 'none';
  let mousePosition = { x: 0, y: 0 };
  let earlyObserver = null;
  let earlyClickableElements = new Set();
  let keyboardListenersActive = false;
  let pendingKeyEvents = [];
  let cursorApplied = false; // Track if cursor has been applied to prevent unnecessary updates
  let cursorSettingsChanged = false; // Track if settings changed to force cursor reapplication
  let isMainExtensionLoaded = false; // Track if main extension has taken over
  let keyboardHelpVisible = false;
  let keyboardLayoutId = (typeof DEFAULT_KEYBOARD_LAYOUT_ID === 'string' && DEFAULT_KEYBOARD_LAYOUT_ID)
    ? DEFAULT_KEYBOARD_LAYOUT_ID
    : 'browsing-right';
  let keyboardHelpRoot = null;
  let keyboardHelpKeyboardContainer = null;
  let keyboardHelpStorageListener = null;
  let onboardingRoot = null;
  let onboardingStorageListener = null;
  let mainLoadedListenerInstalled = false;

  function setupMainLoadedHandoffListener() {
    if (mainLoadedListenerInstalled) return;
    mainLoadedListenerInstalled = true;

    // Clean up when main extension loads - early-inject must yield control.
    // (This used to be wired from the cursor takeover path, but the cursor is now CSS-based,
    // so we listen unconditionally.)
    window.addEventListener('keypilot-main-loaded', () => {
      isMainExtensionLoaded = true;

      // Stop early mouse tracking (main extension will handle this)
      try { document.removeEventListener('mousemove', handleMouseMove); } catch {}

      // Stop early keyboard capture
      try { stopEarlyKeyboardCapture(); } catch {}

      // Stop early DOM observation
      try {
        if (earlyObserver) {
          earlyObserver.disconnect();
          earlyObserver = null;
        }
      } catch {}

      // Stop reacting to storage changes once the main extension is active
      try {
        if (keyboardHelpStorageListener && chrome?.storage?.onChanged) {
          chrome.storage.onChanged.removeListener(keyboardHelpStorageListener);
        }
      } catch {}
      keyboardHelpStorageListener = null;

      try {
        if (cursorSettingsListener && chrome?.storage?.onChanged) {
          chrome.storage.onChanged.removeListener(cursorSettingsListener);
        }
      } catch {}
      cursorSettingsListener = null;

      // Stop reacting to onboarding storage changes once the main extension is active.
      // We keep the onboarding DOM in place so the bundled script can adopt it.
      try {
        if (onboardingStorageListener && chrome?.storage?.onChanged) {
          chrome.storage.onChanged.removeListener(onboardingStorageListener);
        }
      } catch {}
      onboardingStorageListener = null;

      console.log('[KeyPilot Early] Handed off to main extension, cursor control yielded');
    }, { once: true });
  }

  /**
   * Convert backtick-wrapped text to <kbd> tags for keyboard key styling
   * @param {string} text
   * @returns {string}
   */
  function formatKeyboardKeys(text) {
    return String(text || '').replace(/`([^`]+)`/g, '<kbd>$1</kbd>');
  }

  /**
   * Render backtick-wrapped key names as real <kbd> nodes without using innerHTML.
   * This avoids Chromium parser warnings (and potential HTML injection) if task text contains
   * markup like <link>, <meta>, etc.
   *
   * @param {HTMLElement} el
   * @param {string} text
   */
  function renderKeyboardKeysInto(el, text) {
    if (!el) return;
    const s = String(text || '');
    try {
      while (el.firstChild) el.removeChild(el.firstChild);
    } catch {
      // Fallback for unusual nodes
      try { el.textContent = ''; } catch { /* ignore */ }
    }

    // Split on backtick-wrapped segments: even indices are plain text, odd indices are key names.
    const parts = s.split(/`([^`]+)`/g);
    for (let i = 0; i < parts.length; i += 1) {
      const part = parts[i];
      if (!part) continue;
      if (i % 2 === 1) {
        const k = document.createElement('kbd');
        k.textContent = part;
        el.appendChild(k);
      } else {
        el.appendChild(document.createTextNode(part));
      }
    }
  }

  function ensureOnboardingShell() {
    try {
      if (window !== window.top) return null;
      if (onboardingRoot && onboardingRoot.isConnected) return onboardingRoot;

      const existing = document.querySelector('.kp-onboarding-panel[data-kp-early-onboarding="true"]');
      if (existing && existing.isConnected) {
        onboardingRoot = existing;
        return onboardingRoot;
      }

      const root = document.createElement('div');
      root.className = 'kp-onboarding-panel';
      root.hidden = true;
      root.dataset.kpEarlyOnboarding = 'true';
      root.setAttribute('role', 'dialog');
      root.setAttribute('aria-label', 'KeyPilot onboarding walkthrough');

      Object.assign(root.style, {
        position: 'fixed',
        left: '16px',
        top: '16px',
        width: '360px',
        maxWidth: 'calc(100vw - 24px)',
        maxHeight: 'calc(100vh - 24px)',
        // IMPORTANT: keep the shell truly hidden until refreshEarlyOnboardingVisibility()
        // computes `shouldShow`. Some pages override `[hidden]{display:none}` and inline
        // `display:flex` can cause a flash at page load.
        display: 'none',
        flexDirection: 'column',
        overflow: 'hidden',
        zIndex: String(Z_ONBOARDING_PANEL),
        background: 'rgba(18, 18, 18, 0.94)',
        color: 'rgba(255,255,255,0.95)',
        border: '1px solid rgba(255,255,255,0.12)',
        borderRadius: '14px',
        boxShadow: '0 12px 34px rgba(0,0,0,0.45)',
        fontFamily: 'system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif',
        pointerEvents: 'none'
      });

      try { applyPopupThemeVars(root); } catch { /* ignore */ }

      // Add kbd styling for keyboard keys
      const style = document.createElement('style');
      style.textContent = `
        .kp-onboarding-panel kbd {
          font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
          font-size: 11px;
          padding: 1px 6px;
          border: 1px solid #3a3a3a;
          border-bottom-color: #2a2a2a;
          border-radius: 4px;
          background: linear-gradient(180deg, #2b2b2b 0%, #1a1a1a 100%);
          color: #f1f1f1;
        }
      `;
      root.appendChild(style);

      const header = document.createElement('div');
      Object.assign(header.style, {
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'space-between',
        gap: '10px',
        padding: '10px 12px',
        borderBottom: '1px solid rgba(255,255,255,0.10)'
      });

      const titleWrap = document.createElement('div');
      Object.assign(titleWrap.style, {
        display: 'flex',
        flexDirection: 'column',
        gap: '2px',
        minWidth: '0'
      });

      const title = document.createElement('div');
      title.textContent = 'Welcome to KeyPilot';
      title.setAttribute('data-kp-onboarding-title', 'true');
      Object.assign(title.style, {
        fontSize: '13px',
        fontWeight: '800',
        letterSpacing: '0.2px',
        whiteSpace: 'nowrap',
        overflow: 'hidden',
        textOverflow: 'ellipsis'
      });

      const step = document.createElement('div');
      step.textContent = '';
      step.setAttribute('data-kp-onboarding-step', 'true');
      Object.assign(step.style, {
        fontSize: '12px',
        fontWeight: '600',
        opacity: '0.75'
      });

      titleWrap.appendChild(title);

      const navWrap = document.createElement('div');
      Object.assign(navWrap.style, {
        display: 'inline-flex',
        alignItems: 'center',
        gap: '8px',
        flex: '0 0 auto'
      });

      const stepWrap = document.createElement('div');
      Object.assign(stepWrap.style, {
        display: 'inline-flex',
        alignItems: 'center',
        gap: '6px'
      });

      const mkIconBtn = (label, attrName, aria) => {
        const b = document.createElement('button');
        b.type = 'button';
        b.textContent = label;
        b.setAttribute(attrName, 'true');
        if (aria) b.setAttribute('aria-label', aria);
        Object.assign(b.style, {
          width: '28px',
          height: '28px',
          borderRadius: '10px',
          border: '1px solid rgba(255,255,255,0.18)',
          background: 'rgba(255,255,255,0.06)',
          color: 'rgba(255,255,255,0.95)',
          cursor: 'pointer',
          fontSize: '14px',
          lineHeight: '26px',
          padding: '0',
          display: 'inline-flex',
          alignItems: 'center',
          justifyContent: 'center'
        });
        return b;
      };

      const prevBtn = mkIconBtn('', 'data-kp-onboarding-prev', 'Previous slide');
      prevBtn.disabled = true;

      const nextBtn = mkIconBtn('', 'data-kp-onboarding-next', 'Next slide');
      nextBtn.disabled = true;

      stepWrap.appendChild(prevBtn);
      stepWrap.appendChild(step);
      stepWrap.appendChild(nextBtn);

      const resetBtn = document.createElement('button');
      resetBtn.type = 'button';
      resetBtn.textContent = 'Reset';
      resetBtn.setAttribute('data-kp-onboarding-reset', 'true');
      Object.assign(resetBtn.style, {
        height: '28px',
        borderRadius: '999px',
        border: '1px solid rgba(255,255,255,0.18)',
        background: 'rgba(255,255,255,0.06)',
        color: 'rgba(255,255,255,0.92)',
        cursor: 'pointer',
        fontSize: '12px',
        fontWeight: '700',
        padding: '0 10px',
        lineHeight: '26px'
      });

      // Early-inject reset: clear progress + re-enable onboarding.
      resetBtn.addEventListener('click', () => {
        try {
          const progress = {
            slideId: 'basic_navigation',
            completedTaskIds: [],
            onEnterDoneSlideIds: [],
            completed: false,
            timestamp: Date.now()
          };
          const payload = {
            [ONBOARDING_ACTIVE_STORAGE_KEY]: true,
            [ONBOARDING_PROGRESS_STORAGE_KEY]: progress
          };
          chrome.storage.sync.set(payload).catch(() => chrome.storage.local.set(payload).catch(() => {}));
        } catch { /* ignore */ }
      });

      const closeBtn = document.createElement('button');
      closeBtn.type = 'button';
      closeBtn.textContent = '';
      closeBtn.setAttribute('aria-label', 'Close onboarding walkthrough');
      closeBtn.setAttribute('data-kp-onboarding-close', 'true');
      Object.assign(closeBtn.style, {
        width: '30px',
        height: '30px',
        borderRadius: '10px',
        border: '1px solid rgba(255,255,255,0.18)',
        background: 'rgba(255,255,255,0.06)',
        color: 'rgba(255,255,255,0.95)',
        cursor: 'pointer',
        fontSize: '18px',
        lineHeight: '28px',
        padding: '0',
        flex: '0 0 auto'
      });

      // Closing in early-inject should persist, so the panel doesn't come back on the next page.
      closeBtn.addEventListener('click', () => {
        try {
          root.hidden = true;
          // Do not rely on [hidden] alone; some pages override it.
          root.style.display = 'none';
          root.style.pointerEvents = 'none';
        } catch { /* ignore */ }
        try {
          const payload = { [ONBOARDING_ACTIVE_STORAGE_KEY]: false, timestamp: Date.now() };
          chrome.storage.sync.set(payload).catch(() => chrome.storage.local.set(payload).catch(() => {}));
        } catch { /* ignore */ }
      });

      navWrap.appendChild(closeBtn);

      header.appendChild(titleWrap);
      header.appendChild(navWrap);

      const body = document.createElement('div');
      body.setAttribute('data-kp-onboarding-body', 'true');
      Object.assign(body.style, {
        flex: '1',
        overflowY: 'auto',
        minHeight: '0',
        position: 'relative'
      });

      // Create a slide surface for content
      const slideSurface = document.createElement('div');
      slideSurface.setAttribute('data-kp-onboarding-slide-surface', 'true');
      Object.assign(slideSurface.style, {
        padding: '12px'
      });
      body.appendChild(slideSurface);

      // Avoid a visible "Loading" flash: render a best-effort initial checklist immediately.
      // The storage-backed render below will update this as soon as we can read progress.
      try {
        renderEarlyOnboardingContent({ body: slideSurface, titleEl: title, stepEl: step }, { slideId: 'basic_navigation', completedTaskIds: [] });
      } catch { /* ignore */ }

      const footer = document.createElement('div');
      Object.assign(footer.style, {
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'space-between',
        gap: '10px',
        padding: '10px 12px',
        borderTop: '1px solid rgba(255,255,255,0.10)'
      });

      footer.appendChild(stepWrap);
      footer.appendChild(resetBtn);

      root.appendChild(header);
      root.appendChild(body);
      root.appendChild(footer);

      (document.body || document.documentElement).appendChild(root);
      onboardingRoot = root;
      return onboardingRoot;
    } catch {
      return null;
    }
  }

  function getEarlyOnboardingModel() {
    try {
      if (typeof EARLY_ONBOARDING_MODEL === 'object' && EARLY_ONBOARDING_MODEL && Array.isArray(EARLY_ONBOARDING_MODEL.slides)) {
        return EARLY_ONBOARDING_MODEL;
      }
    } catch { /* ignore */ }
    return { slides: [] };
  }

  function findEarlySlide(model, slideId) {
    const slides = model && Array.isArray(model.slides) ? model.slides : [];
    const id = String(slideId || '').trim();
    if (id) {
      const found = slides.find((s) => s && String(s.id || '').trim() === id);
      if (found) return found;
    }
    return slides[0] || null;
  }

  function renderEarlyOnboardingContent(refs, progress) {
    // refs: { body, titleEl, stepEl } (optional) or inferred from onboardingRoot
    const model = getEarlyOnboardingModel();
    const slide = findEarlySlide(model, progress && progress.slideId);
    if (!slide) return;

    const completed = new Set(Array.isArray(progress?.completedTaskIds) ? progress.completedTaskIds.map(String) : []);
    const slides = model.slides || [];
    const slideIndex = Math.max(0, slides.findIndex((s) => s && s.id === slide.id));
    const slideCount = Math.max(1, slides.length || 1);

    // Look for slide surface first, then body as fallback
    const body = refs?.body || 
      onboardingRoot?.querySelector?.('[data-kp-onboarding-slide-surface="true"]') ||
      onboardingRoot?.querySelector?.('[data-kp-onboarding-body="true"]');
    const titleEl = refs?.titleEl || onboardingRoot?.querySelector?.('[data-kp-onboarding-title="true"]');
    const stepEl = refs?.stepEl || onboardingRoot?.querySelector?.('[data-kp-onboarding-step="true"]');
    if (!body) return;

    try {
      if (titleEl) titleEl.textContent = String(slide.title || 'Welcome to KeyPilot');
      if (stepEl) stepEl.textContent = `${slideIndex + 1} / ${slideCount}`;
    } catch { /* ignore */ }

    // Build a stable checklist DOM similar to the bundled OnboardingPanel so takeover doesn't blink.
    try {
      body.textContent = '';

      const list = document.createElement('div');
      Object.assign(list.style, {
        display: 'flex',
        flexDirection: 'column',
        gap: '8px'
      });

      for (const task of slide.tasks || []) {
        if (!task || !task.id) continue;
        const done = completed.has(task.id);

        const row = document.createElement('div');
        row.setAttribute('data-kp-onboarding-task-id', task.id);
        Object.assign(row.style, {
          display: 'flex',
          alignItems: 'flex-start',
          gap: '10px',
          padding: '8px 10px',
          borderRadius: '10px',
          border: '1px solid rgba(255,255,255,0.10)',
          background: done ? 'rgba(46, 204, 113, 0.10)' : 'rgba(255,255,255,0.04)'
        });

        const box = document.createElement('div');
        box.setAttribute('aria-hidden', 'true');
        Object.assign(box.style, {
          width: '18px',
          height: '18px',
          borderRadius: '6px',
          border: done ? '1px solid rgba(46, 204, 113, 0.9)' : '1px solid rgba(255,255,255,0.22)',
          background: done ? 'rgba(46, 204, 113, 0.85)' : 'transparent',
          boxShadow: done ? '0 0 0 2px rgba(46, 204, 113, 0.18)' : 'none',
          flex: '0 0 auto',
          marginTop: '1px',
          position: 'relative'
        });

        if (done) {
          const check = document.createElement('div');
          check.textContent = '';
          Object.assign(check.style, {
            position: 'absolute',
            inset: '0',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            fontSize: '13px',
            fontWeight: '800',
            color: '#0b1410'
          });
          box.appendChild(check);
        }

        const text = document.createElement('div');
        // Avoid innerHTML parsing (can emit warnings on some sites if content contains head-only tags)
        renderKeyboardKeysInto(text, task.label || task.id);
        Object.assign(text.style, {
          fontSize: '13px',
          lineHeight: '1.35',
          color: done ? 'rgba(255,255,255,0.92)' : 'rgba(255,255,255,0.88)',
          opacity: done ? '0.95' : '1'
        });

        row.appendChild(box);
        row.appendChild(text);
        list.appendChild(row);
      }

      const footer = document.createElement('div');
      Object.assign(footer.style, {
        marginTop: '10px',
        fontSize: '12px',
        opacity: '0.78',
        lineHeight: '1.35',
        color: 'rgba(255,255,255,0.85)'
      });
      footer.textContent = 'Tip: Press Alt + / to re-open this walkthrough later.';

      body.appendChild(list);
      body.appendChild(footer);
    } catch { /* ignore */ }
  }

  async function readOnboardingState() {
    // returns: { active: boolean|null, completed: boolean|null, slideId: string|null, completedTaskIds: string[] }
    const result = { active: null, completed: null, slideId: null, completedTaskIds: [] };
    const parse = (obj) => {
      try {
        if (!obj || typeof obj !== 'object') return;
        if (typeof obj[ONBOARDING_ACTIVE_STORAGE_KEY] === 'boolean') result.active = obj[ONBOARDING_ACTIVE_STORAGE_KEY];
        const prog = obj[ONBOARDING_PROGRESS_STORAGE_KEY];
        if (prog && typeof prog === 'object') {
          if (typeof prog.completed === 'boolean') result.completed = prog.completed;
          if (typeof prog.slideId === 'string') result.slideId = prog.slideId;
          if (Array.isArray(prog.completedTaskIds)) result.completedTaskIds = prog.completedTaskIds.map(String);
        }
      } catch { /* ignore */ }
    };

    try {
      const sync = await chrome.storage.sync.get([ONBOARDING_ACTIVE_STORAGE_KEY, ONBOARDING_PROGRESS_STORAGE_KEY]);
      parse(sync);
      if (result.active !== null) return result;
    } catch { /* ignore */ }

    try {
      const local = await chrome.storage.local.get([ONBOARDING_ACTIVE_STORAGE_KEY, ONBOARDING_PROGRESS_STORAGE_KEY]);
      parse(local);
    } catch { /* ignore */ }

    return result;
  }

  async function readEnabledState() {
    // returns: { enabled: boolean|null }
    const result = { enabled: null };
    const KEY = 'keypilot_enabled';
    const parse = (obj) => {
      try {
        if (!obj || typeof obj !== 'object') return;
        if (typeof obj[KEY] === 'boolean') result.enabled = obj[KEY];
      } catch { /* ignore */ }
    };

    try {
      const sync = await chrome.storage.sync.get([KEY]);
      parse(sync);
      if (result.enabled !== null) return result;
    } catch { /* ignore */ }

    try {
      const local = await chrome.storage.local.get([KEY]);
      parse(local);
    } catch { /* ignore */ }

    return result;
  }

  async function refreshEarlyOnboardingVisibility() {
    try {
      if (isMainExtensionLoaded) return;
      if (window !== window.top) return;
      const root = ensureOnboardingShell();
      if (!root) return;

      const state = await readOnboardingState();
      const enabledState = await readEnabledState();
      // Conservative default: if we can't confirm enabled, do not show.
      // This matches the bundled onboarding behavior and prevents load-time flashes.
      const isEnabled = enabledState.enabled === true;
      const shouldShow = isEnabled && state.active === true && state.completed !== true;
      root.hidden = !shouldShow;
      // Do not rely on [hidden] alone; some pages override it.
      root.style.display = shouldShow ? 'flex' : 'none';
      root.style.pointerEvents = shouldShow ? 'auto' : 'none';
      if (shouldShow) {
        // Keep the early checklist in sync so the main bundled UI can adopt without a visual "pop".
        try { renderEarlyOnboardingContent(null, state); } catch { /* ignore */ }
      }
    } catch {
      // ignore
    }
  }

  function setupEarlyOnboardingStorageSync() {
    try {
      if (window !== window.top) return;
      ensureOnboardingShell();
      refreshEarlyOnboardingVisibility(); // async

      if (!chrome?.storage?.onChanged?.addListener) return;
      if (onboardingStorageListener) return;

      onboardingStorageListener = (changes, area) => {
        try {
          if (isMainExtensionLoaded) return;
          if (area !== 'sync' && area !== 'local') return;
          if (!changes) return;
          if (!changes[ONBOARDING_ACTIVE_STORAGE_KEY] && !changes[ONBOARDING_PROGRESS_STORAGE_KEY] && !changes['keypilot_enabled']) return;
          refreshEarlyOnboardingVisibility(); // async
        } catch { /* ignore */ }
      };

      chrome.storage.onChanged.addListener(onboardingStorageListener);
    } catch {
      // ignore
    }
  }

  function ensureKeybindingsUiStylesInjected(doc) {
    try {
      if (!doc || !doc.head) return;
      if (doc.head.querySelector(`style[${KEYBINDINGS_UI_STYLE_ATTR}]`)) return;
      const style = doc.createElement('style');
      style.setAttribute(KEYBINDINGS_UI_STYLE_ATTR, 'true');
      // Replace build-time font placeholders with runtime extension URLs (required on real web pages).
      let css = KEYBINDINGS_UI_EARLY_CSS;
      try {
        const getURL = chrome && chrome.runtime && chrome.runtime.getURL ? chrome.runtime.getURL.bind(chrome.runtime) : null;
        if (getURL) {
          css = css
            .replaceAll('__KP_FONT_ROBOTECH_URL__', getURL('fonts/ROBOTECHGPRegular.ttf'))
            .replaceAll('__KP_FONT_TITILLIUM_URL__', getURL('fonts/TitilliumTextRegular.otf'))
            .replaceAll('__KP_FONT_CUBELLAN_URL__', getURL('fonts/CubellanRegular.ttf'))
            .replaceAll('__KP_FONT_EZARION_URL__', getURL('fonts/EzarionRegular.ttf'))
            .replaceAll('__KP_FONT_DOSIS_URL__', getURL('fonts/DosisBook.ttf'));
        }
      } catch {
        // ignore; fallback to placeholders (bundled UI will overwrite later)
      }
      style.textContent = css;
      doc.head.appendChild(style);
    } catch {
      // ignore
    }
  }

  function el(doc, tag, className, text) {
    const node = doc.createElement(tag);
    if (className) node.className = className;
    if (text !== undefined) node.textContent = text;
    return node;
  }

  function normalizeKeyboardLayoutId(raw) {
    const v = String(raw || '').trim();
    if (v === 'browsing-left') return 'browsing-left';
    return 'browsing-right';
  }

  function getEarlyKeyboardDataForLayout(layoutId) {
    const id = normalizeKeyboardLayoutId(layoutId);
    try {
      const layout = (typeof KEYBOARD_LAYOUTS_BY_ID === 'object' && KEYBOARD_LAYOUTS_BY_ID && KEYBOARD_LAYOUTS_BY_ID[id])
        ? KEYBOARD_LAYOUTS_BY_ID[id]
        : KEYBINDINGS_KEYBOARD_LAYOUT;
      const bindings = (typeof EARLY_KEYBINDINGS_BY_ID === 'object' && EARLY_KEYBINDINGS_BY_ID && EARLY_KEYBINDINGS_BY_ID[id])
        ? EARLY_KEYBINDINGS_BY_ID[id]
        : EARLY_KEYBINDINGS;
      return { id, layout, bindings };
    } catch {
      return { id: DEFAULT_KEYBOARD_LAYOUT_ID || 'browsing-right', layout: KEYBINDINGS_KEYBOARD_LAYOUT, bindings: EARLY_KEYBINDINGS };
    }
  }

  function renderEarlyKeyboard(container, { layoutId } = {}) {
    if (!container) return;
    const doc = container.ownerDocument || document;
    ensureKeybindingsUiStylesInjected(doc);

    // If already rendered, don't redo work.
    let existing = null;
    try { existing = container.querySelector(':scope > .keyboard-visual'); } catch { /* ignore */ }
    if (!existing) {
      try { existing = container.querySelector('.keyboard-visual'); } catch { /* ignore */ }
    }
    if (existing && existing.dataset && existing.dataset.kpKeyboardBuilt === 'true') {
      const existingLayoutId = String(existing.dataset.kpLayoutId || '');
      const desired = normalizeKeyboardLayoutId(layoutId || DEFAULT_KEYBOARD_LAYOUT_ID);
      if (!existingLayoutId || existingLayoutId === desired) return;
      // Layout changed: re-render so key positions update (prevents right->left mismatch).
    }

    container.textContent = '';
    const visual = el(doc, 'div', 'keyboard-visual kp-keybindings-ui');
    visual.dataset.kpKeyboardBuilt = 'true';
    try {
      const desired = normalizeKeyboardLayoutId(layoutId || DEFAULT_KEYBOARD_LAYOUT_ID);
      visual.dataset.kpLayoutId = desired;
    } catch { /* ignore */ }
    container.appendChild(visual);

    const data = getEarlyKeyboardDataForLayout(layoutId || DEFAULT_KEYBOARD_LAYOUT_ID);
    const layout = data.layout || KEYBINDINGS_KEYBOARD_LAYOUT;
    const bindings = data.bindings || EARLY_KEYBINDINGS;

    for (const row of layout) {
      const rowEl = el(doc, 'div', 'keyboard-row');
      visual.appendChild(rowEl);

      for (const item of row) {
        if (item.type === 'special') {
          rowEl.appendChild(el(doc, 'div', item.className || 'key', item.text));
          continue;
        }
        if (item.type === 'key') {
          rowEl.appendChild(el(doc, 'div', 'key', item.text));
          continue;
        }

        const binding = bindings[item.id];
        const baseClass = item.className || 'key';
        const className = `${baseClass}${binding && binding.keyboardClass ? ' ' + binding.keyboardClass : ''}`;
        const keyEl = el(doc, 'div', className);
        keyEl.dataset.kpActionId = item.id;
        keyEl.dataset.kpBaseClass = baseClass;
        keyEl.setAttribute('role', 'button');
        keyEl.setAttribute('tabindex', '0');
        keyEl.title = (binding && (binding.description || binding.label)) || item.fallbackText || item.id;

        const main = el(doc, 'div', 'key-main', (binding && binding.label) || item.fallbackText || item.id);
        keyEl.appendChild(main);

        const labelText = (binding && (binding.displayKey || binding.keyLabel)) || '';
        if (labelText) {
          keyEl.appendChild(el(doc, 'div', 'key-label', labelText));
        }

        rowEl.appendChild(keyEl);
      }
    }
  }

  /**
   * Generate SVG data URI for cursor
   */
  function getCursorDataUri(options = {}) {
    // Extract parameters with defaults
    const {
      crossHairQuadrantWidth = 15,
      gap = 0,
      strokeLineCap = 'round',
      strokeWidth = 4,
      crossHairScalingFactor = 1
    } = options;

    // Apply scaling factor
    const scaledGap = gap * crossHairScalingFactor;
    const scaledWidth = crossHairQuadrantWidth * crossHairScalingFactor;

    // Calculate segment positions (center is now at 30,30 for 60x60 canvas)
    const centerX = 30;
    const centerY = 30;
    
    let segmentStart, segmentEnd, segmentStart2, segmentEnd2;
    
    if (scaledGap === 0) {
      // Intersecting lines: bars extend from center outward
      segmentStart = centerY - scaledWidth;
      segmentEnd = centerY;
      segmentStart2 = centerY;
      segmentEnd2 = centerY + scaledWidth;
    } else {
      // Four separate bars: each bar is `gap` pixels away from center
      segmentStart = centerY - scaledGap - scaledWidth;
      segmentEnd = centerY - scaledGap;
      segmentStart2 = centerY + scaledGap;
      segmentEnd2 = centerY + scaledGap + scaledWidth;
    }

    const color = FOCUS_GREEN_BRIGHT;
    const svgContent = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 60 60" width="60" height="60">
      <line x1="30" y1="${segmentStart}" x2="30" y2="${segmentEnd}" stroke="${color}" stroke-width="${strokeWidth}" stroke-linecap="${strokeLineCap}"/>
      <line x1="30" y1="${segmentStart2}" x2="30" y2="${segmentEnd2}" stroke="${color}" stroke-width="${strokeWidth}" stroke-linecap="${strokeLineCap}"/>
      <line x1="${segmentStart}" y1="30" x2="${segmentEnd}" y2="30" stroke="${color}" stroke-width="${strokeWidth}" stroke-linecap="${strokeLineCap}"/>
      <line x1="${segmentStart2}" y1="30" x2="${segmentEnd2}" y2="30" stroke="${color}" stroke-width="${strokeWidth}" stroke-linecap="${strokeLineCap}"/>
    </svg>`;
    const encoded = encodeURIComponent(svgContent);
    return `data:image/svg+xml,${encoded}`;
  }

  /**
   * Get cursor settings from storage
   */
  async function getCursorSettings() {
    const defaultSettings = {
      cursorMode: CURSOR_MODE.NO_CUSTOM_CURSORS,
      type: 'crosshair',
      lineWidth: 4,
      sizePixels: 10,
      gap: 6
    };

    try {
      // Try sync storage first
      const syncResult = await chrome.storage.sync.get([SETTINGS_STORAGE_KEY]);
      const stored = syncResult?.[SETTINGS_STORAGE_KEY];
      
      if (stored && typeof stored === 'object') {
        const cursorMode = stored.cursorMode === CURSOR_MODE.CUSTOM_CURSORS || stored.cursorMode === CURSOR_MODE.NO_CUSTOM_CURSORS
          ? stored.cursorMode
          : defaultSettings.cursorMode;

        const cursor = (stored.clickMode && stored.clickMode.cursor && typeof stored.clickMode.cursor === 'object')
          ? stored.clickMode.cursor
          : {};
        // Check if gap is missing or if it's the old default (0) with old sizePixels default (15)
        // This handles fresh installs and migration from old defaults
        const hasOldDefaults = cursor.gap === 0 && cursor.sizePixels === 15;
        const gapValue = (typeof cursor.gap === 'number' && cursor.gap !== null && !hasOldDefaults) 
          ? cursor.gap 
          : defaultSettings.gap;
        const sizePixelsValue = (typeof cursor.sizePixels === 'number' && cursor.sizePixels !== null && !hasOldDefaults)
          ? cursor.sizePixels
          : defaultSettings.sizePixels;
        
        return {
          cursorMode,
          type: cursor.type || defaultSettings.type,
          lineWidth: typeof cursor.lineWidth === 'number' ? cursor.lineWidth : defaultSettings.lineWidth,
          sizePixels: sizePixelsValue,
          gap: gapValue
        };
      }
    } catch (syncError) {
      // Fallback to local storage
      try {
        const localResult = await chrome.storage.local.get([SETTINGS_STORAGE_KEY]);
        const stored = localResult?.[SETTINGS_STORAGE_KEY];
        
        if (stored && typeof stored === 'object') {
          const cursorMode = stored.cursorMode === CURSOR_MODE.CUSTOM_CURSORS || stored.cursorMode === CURSOR_MODE.NO_CUSTOM_CURSORS
            ? stored.cursorMode
            : defaultSettings.cursorMode;

          const cursor = (stored.clickMode && stored.clickMode.cursor && typeof stored.clickMode.cursor === 'object')
            ? stored.clickMode.cursor
            : {};
          // Check if gap is missing or if it's the old default (0) with old sizePixels default (15)
          // This handles fresh installs and migration from old defaults
          const hasOldDefaults = cursor.gap === 0 && cursor.sizePixels === 15;
          const gapValue = (typeof cursor.gap === 'number' && cursor.gap !== null && !hasOldDefaults) 
            ? cursor.gap 
            : defaultSettings.gap;
          const sizePixelsValue = (typeof cursor.sizePixels === 'number' && cursor.sizePixels !== null && !hasOldDefaults)
            ? cursor.sizePixels
            : defaultSettings.sizePixels;
          
          return {
            cursorMode,
            type: cursor.type || defaultSettings.type,
            lineWidth: typeof cursor.lineWidth === 'number' ? cursor.lineWidth : defaultSettings.lineWidth,
            sizePixels: sizePixelsValue,
            gap: gapValue
          };
        }
      } catch (localError) {
        // Ignore
      }
    }
    
    return defaultSettings;
  }

  /**
   * Apply CSS cursor for early injection
   */
  async function applyEarlyCursor() {
    // Only apply once to prevent flickering (unless settings changed)
    if (cursorApplied && !cursorSettingsChanged) {
      return;
    }

    const settings = await getCursorSettings();
    cursorSettingsChanged = false;

    // Cursor mode disabled: do not override the page cursor at all.
    if (settings.cursorMode !== CURSOR_MODE.CUSTOM_CURSORS) {
      try {
        if (document.documentElement) {
          document.documentElement.classList.remove(CURSOR_HIDDEN_CLASS);
          document.documentElement.style.removeProperty(CURSOR_VAR);
          document.documentElement.style.cursor = '';
        }
        if (document.body) {
          document.body.style.cursor = '';
        }
      } catch {}
      cursorApplied = true;
      return;
    }

    // Handle native cursor types
    if (settings.type === 'native_arrow') {
      try {
        if (document.documentElement) {
          document.documentElement.style.setProperty(CURSOR_VAR, 'default');
          document.documentElement.classList.add(CURSOR_HIDDEN_CLASS);
        }
      } catch {}
      cursorApplied = true;
      return;
    }

    if (settings.type === 'native_pointer') {
      try {
        if (document.documentElement) {
          document.documentElement.style.setProperty(CURSOR_VAR, 'pointer');
          document.documentElement.classList.add(CURSOR_HIDDEN_CLASS);
        }
      } catch {}
      cursorApplied = true;
      return;
    }

    // Use settings to generate cursor
    const cursorUri = getCursorDataUri({
      crossHairQuadrantWidth: settings.sizePixels,
      gap: settings.gap,
      strokeWidth: settings.lineWidth,
      crossHairScalingFactor: 1
    });
    const cursorValue = `url("${cursorUri}") 30 30, auto`;

    // Mirror main extension behavior: set the CSS variable + class.
    // This makes the cursor apply across all elements via the injected CSS above.
    try {
      if (document.documentElement) {
        document.documentElement.style.setProperty(CURSOR_VAR, cursorValue);
        document.documentElement.classList.add(CURSOR_HIDDEN_CLASS);
      }
    } catch {}

    cursorApplied = true;
  }

  /**
   * Update cursor position (not needed for CSS cursor, but kept for compatibility)
   */
  function updateCursorPosition(x, y) {
    mousePosition = { x, y };
  }

  /**
   * Show/hide cursor based on extension state
   */
  async function updateCursorVisibility() {
    // If main extension has loaded, it's in charge of the cursor
    if (isMainExtensionLoaded) {
      return;
    }

    if (isExtensionEnabled) {
      await applyEarlyCursor();
    } else {
      // Reset cursor applied flag when disabling
      cursorApplied = false;
      try {
        if (document.documentElement) {
          document.documentElement.classList.remove(CURSOR_HIDDEN_CLASS);
          document.documentElement.style.removeProperty(CURSOR_VAR);
          document.documentElement.style.cursor = 'default';
        }
        if (document.body) {
          document.body.style.cursor = 'default';
        }
      } catch {}
    }
  }

  /**
   * Ensure the floating keyboard reference shell exists early (document_start).
   * The bundled extension will "adopt" this element later to avoid flicker.
   */
  function ensureEarlyFloatingKeyboardHelpShell() {
    if (isMainExtensionLoaded) return;
    if (keyboardHelpRoot && keyboardHelpRoot.isConnected) return;

    const doc = document;
    const root = doc.createElement('div');
    root.className = 'kp-floating-keyboard-help';
    root.hidden = true;
    root.setAttribute('role', 'dialog');
    root.setAttribute('aria-label', 'KeyPilot keyboard reference');
    root.setAttribute('data-kp-early-floating-keyboard', 'true');

    // Inline styles to avoid depending on any page CSS.
    Object.assign(root.style, {
      position: 'fixed',
      left: '16px',
      bottom: '16px',
      width: '740px',
      maxWidth: 'calc(100vw - 24px)',
      maxHeight: 'calc(100vh - 24px)',
      overflow: 'auto',
      zIndex: String(Z_FLOATING_KEYBOARD_HELP),
      background: 'rgba(20, 20, 20, 0.92)',
      color: 'rgba(255,255,255,0.95)',
      border: '1px solid rgba(255,255,255,0.12)',
      borderRadius: '12px',
      boxShadow: '0 10px 30px rgba(0,0,0,0.4)',
      /* backdrop-filter removed to prevent Chrome z-index stacking context bug */
      fontFamily: 'system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif',
      pointerEvents: 'auto'
    });
    // Match popup.html theme tokens so the early-rendered keyboard matches the popup.
    try { applyPopupThemeVars(root); } catch { /* ignore */ }

    const header = doc.createElement('div');
    header.id = 'kpv2-keyboard-help-header';
    Object.assign(header.style, {
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'space-between',
      gap: '12px',
      padding: '0px 8px',
      borderBottom: '1px solid rgba(255,255,255,0.1)'
    });

    const title = doc.createElement('div');
    title.id = 'kpv2-keyboard-help-title';
    title.textContent = 'KeyPilot keyboard reference';
    Object.assign(title.style, {
      fontSize: '13px',
      fontWeight: '600',
      letterSpacing: '0.2px'
    });

    const hint = doc.createElement('div');
    hint.id = 'kpv2-keyboard-help-hint';
    hint.textContent = 'Press K to toggle';
    hint.setAttribute('data-kp-floating-keyboard-hint', 'true');
    Object.assign(hint.style, {
      marginLeft: 'auto',
      fontSize: '12px',
      fontWeight: '500',
      opacity: '0.8'
    });

    const closeBtn = doc.createElement('button');
    closeBtn.type = 'button';
    closeBtn.textContent = '';
    closeBtn.setAttribute('aria-label', 'Close keyboard reference');
    closeBtn.setAttribute('data-kp-floating-keyboard-close', 'true');
    Object.assign(closeBtn.style, {
      width: '28px',
      height: '28px',
      borderRadius: '8px',
      border: '1px solid rgba(255,255,255,0.18)',
      background: 'rgba(255,255,255,0.06)',
      color: 'rgba(255,255,255,0.95)',
      cursor: 'pointer',
      fontSize: '18px',
      lineHeight: '26px',
      padding: '0',
      flex: '0 0 auto'
    });
    closeBtn.addEventListener('click', (e) => {
      // Match main extension behavior: hide without persisting.
      try { e.preventDefault(); e.stopPropagation(); } catch {}
      if (root) root.hidden = true;
    });

    header.appendChild(title);
    header.appendChild(hint);
    header.appendChild(closeBtn);

    const body = doc.createElement('div');
    body.id = 'kpv2-keyboard-help-body';
    Object.assign(body.style, { padding: '10px 12px' });

    const keyboardContainer = doc.createElement('div');
    keyboardContainer.id = 'kpv2-keyboard-help-keyboard';
    keyboardContainer.className = 'kp-floating-keyboard-help__keyboard';
    keyboardContainer.textContent = '';
    body.appendChild(keyboardContainer);

    root.appendChild(header);
    root.appendChild(body);

    // Attach to DOM (body may not exist at document_start).
    (doc.body || doc.documentElement).appendChild(root);

    keyboardHelpRoot = root;
    keyboardHelpKeyboardContainer = keyboardContainer;

    // Pre-render the keyboard immediately so the panel doesn't start as only a titlebar.
    renderEarlyKeyboard(keyboardContainer, { layoutId: keyboardLayoutId });
  }

  function updateKeyboardHelpHintForLayout(layoutId) {
    try {
      if (!keyboardHelpRoot) return;
      const hint = keyboardHelpRoot.querySelector('#kpv2-keyboard-help-hint');
      if (!hint) return;
      const data = getEarlyKeyboardDataForLayout(layoutId || keyboardLayoutId);
      const binding = data?.bindings?.TOGGLE_KEYBOARD_HELP;
      const key = binding && (binding.displayKey || binding.keyLabel) ? String(binding.displayKey || binding.keyLabel) : 'K';
      hint.textContent = `Press ${key} to toggle`;
    } catch { /* ignore */ }
  }

  function applyEarlyKeyboardHelpVisibility(visible) {
    if (isMainExtensionLoaded) return;
    keyboardHelpVisible = Boolean(visible);

    // If extension is disabled, keep it hidden but remember desired state.
    ensureEarlyFloatingKeyboardHelpShell();
    if (!keyboardHelpRoot) return;
    keyboardHelpRoot.hidden = !(isExtensionEnabled && keyboardHelpVisible);
  }

  async function getKeyboardHelpVisibleFromStorage() {
    const key = KEYBOARD_HELP_STORAGE_KEY;
    try {
      const syncResult = await chrome.storage.sync.get([key]);
      if (typeof syncResult?.[key] === 'boolean') return syncResult[key];
    } catch {}
    try {
      const localResult = await chrome.storage.local.get([key]);
      if (typeof localResult?.[key] === 'boolean') return localResult[key];
    } catch {}
    return false;
  }

  function setupKeyboardHelpStorageListener() {
    if (keyboardHelpStorageListener || !chrome?.storage?.onChanged) return;
    keyboardHelpStorageListener = (changes, areaName) => {
      if (isMainExtensionLoaded) return;
      if (!changes || (areaName !== 'sync' && areaName !== 'local')) return;
      if (!Object.prototype.hasOwnProperty.call(changes, KEYBOARD_HELP_STORAGE_KEY)) return;
      const next = Boolean(changes[KEYBOARD_HELP_STORAGE_KEY]?.newValue);
      applyEarlyKeyboardHelpVisibility(next);
    };
    try {
      chrome.storage.onChanged.addListener(keyboardHelpStorageListener);
    } catch {}
  }

  let cursorSettingsListener = null;

  function setupCursorSettingsListener() {
    if (cursorSettingsListener || !chrome?.storage?.onChanged) return;
    cursorSettingsListener = (changes, areaName) => {
      if (isMainExtensionLoaded) return;
      if (!changes || (areaName !== 'sync' && areaName !== 'local')) return;
      if (!Object.prototype.hasOwnProperty.call(changes, SETTINGS_STORAGE_KEY)) return;
      
      // Mark that settings changed so cursor will be reapplied
      cursorSettingsChanged = true;
      cursorApplied = false; // Force reapplication

      // Also refresh early keyboard layout selection (prevents layout flicker if user changes it
      // before the bundled content script has taken over).
      try {
        const next = changes[SETTINGS_STORAGE_KEY]?.newValue;
        const nextId = normalizeKeyboardLayoutId(next && typeof next === 'object' ? next.keyboardLayoutId : null);
        if (nextId && nextId !== keyboardLayoutId) {
          keyboardLayoutId = nextId;
          try { renderEarlyKeyboard(keyboardHelpKeyboardContainer, { layoutId: keyboardLayoutId }); } catch { /* ignore */ }
          updateKeyboardHelpHintForLayout(keyboardLayoutId);
        }
      } catch { /* ignore */ }
      
      if (isExtensionEnabled) {
        applyEarlyCursor().catch(() => {});
      }
    };
    try {
      chrome.storage.onChanged.addListener(cursorSettingsListener);
    } catch {}
  }

  /**
   * Handle mouse movement for early cursor tracking
   */
  function handleMouseMove(event) {
    if (!isExtensionEnabled) return;
    updateCursorPosition(event.clientX, event.clientY);
  }

  /**
   * Initialize early storage for faster state loading
   */
  function initEarlyStorage() {
    // Pre-warm storage connections for faster access
    if (typeof chrome !== 'undefined' && chrome.storage) {
      // Test storage availability early
      chrome.storage.sync.get(['keypilot_enabled', KEYBOARD_HELP_STORAGE_KEY, SETTINGS_STORAGE_KEY], (result) => {
        if (chrome.runtime.lastError) {
          // Storage not available, will fallback to localStorage
          isExtensionEnabled = true; // Default to enabled
          updateCursorVisibility();
          ensureEarlyFloatingKeyboardHelpShell();
          applyEarlyKeyboardHelpVisibility(false);
          return;
        }
        isExtensionEnabled = result.keypilot_enabled !== false;
        keyboardHelpVisible = result[KEYBOARD_HELP_STORAGE_KEY] === true;
        try {
          const st = result && result[SETTINGS_STORAGE_KEY] && typeof result[SETTINGS_STORAGE_KEY] === 'object' ? result[SETTINGS_STORAGE_KEY] : null;
          keyboardLayoutId = normalizeKeyboardLayoutId(st && st.keyboardLayoutId);
        } catch {
          keyboardLayoutId = normalizeKeyboardLayoutId(keyboardLayoutId);
        }
        updateCursorVisibility();
        ensureEarlyFloatingKeyboardHelpShell();
        try { renderEarlyKeyboard(keyboardHelpKeyboardContainer, { layoutId: keyboardLayoutId }); } catch { /* ignore */ }
        updateKeyboardHelpHintForLayout(keyboardLayoutId);
        applyEarlyKeyboardHelpVisibility(keyboardHelpVisible);
        setupKeyboardHelpStorageListener();
        setupCursorSettingsListener();
      });
    } else {
      // No chrome storage available, default to enabled
      isExtensionEnabled = true;
      updateCursorVisibility();
      ensureEarlyFloatingKeyboardHelpShell();
      applyEarlyKeyboardHelpVisibility(false);
    }
  }

  /**
   * Check extension state from storage
   */
  async function checkExtensionState() {
    try {
      if (typeof chrome !== 'undefined' && chrome.storage) {
        const result = await chrome.storage.sync.get(['keypilot_enabled', KEYBOARD_HELP_STORAGE_KEY]);
        isExtensionEnabled = result.keypilot_enabled !== false; // Default to true
        keyboardHelpVisible = result[KEYBOARD_HELP_STORAGE_KEY] === true;
      }
    } catch (error) {
      // Fallback to localStorage if Chrome storage fails
      try {
        const stored = localStorage.getItem('keypilot_enabled');
        isExtensionEnabled = stored !== 'false';
      } catch (e) {
        isExtensionEnabled = true; // Default enabled
      }
    }
    updateCursorVisibility();
    ensureEarlyFloatingKeyboardHelpShell();
    applyEarlyKeyboardHelpVisibility(keyboardHelpVisible);
    setupKeyboardHelpStorageListener();
    setupCursorSettingsListener();
  }

  /**
   * Listen for extension state changes
   */
  function setupStateListener() {
    if (typeof chrome !== 'undefined' && chrome.runtime) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
        if (message.type === 'EXTENSION_TOGGLED') {
          isExtensionEnabled = message.enabled;
          updateCursorVisibility();
          applyEarlyKeyboardHelpVisibility(keyboardHelpVisible);
        } else if (message.type === 'CURSOR_MODE_CHANGE') {
          currentMode = message.mode;
          // Early cursor only shows basic crosshair, mode changes handled by main extension
        }
      });
    }
  }

  /**
   * Inject essential CSS for early cursor styling
   */
  function injectEarlyCSS() {
    const existing = document.getElementById(STYLE_ID);
    if (existing) {
      try {
        existing.textContent = EARLY_CSS;
      } catch {}
      return;
    }
    const style = document.createElement('style');
    style.id = STYLE_ID;
    style.textContent = EARLY_CSS;
    
    // Inject at the end of head to prevent override, or use documentElement
    const target = document.head || document.documentElement;
    if (target) {
      target.appendChild(style);
    }
  }

  /**
   * Re-inject CSS to ensure it's not overridden by page styles
   */
  function reInjectCSS() {
    const existingStyle = document.getElementById(STYLE_ID);
    if (existingStyle) {
      existingStyle.remove();
    }
    injectEarlyCSS();
  }

  /**
   * Check if element is clickable for early detection
   */
  function isClickableElement(element) {
    if (!element || element.nodeType !== Node.ELEMENT_NODE) return false;
    
    const tagName = element.tagName.toLowerCase();
    const clickableTags = ['a', 'button', 'input', 'select', 'textarea'];
    
    return clickableTags.includes(tagName) || 
           element.hasAttribute('onclick') ||
           element.getAttribute('role') === 'button' ||
           element.getAttribute('role') === 'link';
  }

  /**
   * Start early DOM observation for clickable elements
   */
  function startEarlyDOMObservation() {
    if (!window.MutationObserver) return;

    earlyObserver = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        // Check added nodes
        mutation.addedNodes.forEach((node) => {
          if (node.nodeType === Node.ELEMENT_NODE) {
            // Check the node itself
            if (isClickableElement(node)) {
              earlyClickableElements.add(node);
            }
            
            // Check child elements (lightweight scan)
            const clickables = node.querySelectorAll?.('a, button, input, select, textarea, [role="button"], [role="link"]');
            if (clickables) {
              clickables.forEach(el => earlyClickableElements.add(el));
            }
          }
        });

        // Remove deleted nodes
        mutation.removedNodes.forEach((node) => {
          if (node.nodeType === Node.ELEMENT_NODE) {
            earlyClickableElements.delete(node);
          }
        });
      });
    });

    // Start observing
    earlyObserver.observe(document.documentElement || document, {
      childList: true,
      subtree: true
    });

    // Initial scan of existing elements
    const existingClickables = document.querySelectorAll('a, button, input, select, textarea, [role="button"], [role="link"]');
    existingClickables.forEach(el => earlyClickableElements.add(el));
  }

  /**
   * Handle early keyboard events for immediate responsiveness
   */
  function handleEarlyKeydown(event) {
    // Handle Alt+K toggle immediately for responsiveness - ALWAYS check this regardless of extension state
    // Check for Alt key (covers both left and right Alt) and K key (case insensitive)
    if ((event.altKey || event.code === 'AltRight') && (event.key === 'k' || event.key === 'K' || event.code === 'KeyK')) {
      event.preventDefault();
      // Send toggle message to background script
      if (typeof chrome !== 'undefined' && chrome.runtime) {
        chrome.runtime.sendMessage({ type: 'KP_TOGGLE_STATE' });
      }
      return; // Don't process this key further
    }

    if (!isExtensionEnabled) return;

    // Store key event for main extension
    pendingKeyEvents.push({
      key: event.key,
      code: event.code,
      timestamp: Date.now(),
      ctrlKey: event.ctrlKey,
      altKey: event.altKey,
      shiftKey: event.shiftKey,
      metaKey: event.metaKey
    });

    // Keep only recent events (last 5 seconds)
    const fiveSecondsAgo = Date.now() - 5000;
    pendingKeyEvents = pendingKeyEvents.filter(e => e.timestamp > fiveSecondsAgo);
  }

  /**
   * Start early keyboard event capture
   */
  function startEarlyKeyboardCapture() {
    if (keyboardListenersActive) return;
    
    document.addEventListener('keydown', handleEarlyKeydown, { 
      passive: false, 
      capture: true 
    });
    keyboardListenersActive = true;
  }

  /**
   * Stop early keyboard event capture
   */
  function stopEarlyKeyboardCapture() {
    if (!keyboardListenersActive) return;
    
    document.removeEventListener('keydown', handleEarlyKeydown, { capture: true });
    keyboardListenersActive = false;
  }

  /**
   * Initialize early injection
   */
  function initEarlyInjection() {
    setupMainLoadedHandoffListener();
    // Initialize early storage for faster state loading
    initEarlyStorage();
    
    // Inject CSS immediately for proper styling
    injectEarlyCSS();
    
    // Start early DOM observation
    startEarlyDOMObservation();
    
    // Start early keyboard capture for immediate responsiveness
    startEarlyKeyboardCapture();
    
    // Apply CSS cursor immediately
    const applyCursor = () => {
      if (document.documentElement || document.body) {
        // Re-inject CSS after DOM is ready to prevent override
        reInjectCSS();
        // Start mouse tracking
        document.addEventListener('mousemove', handleMouseMove, { passive: true });
        // Ensure cursor is visible
        updateCursorVisibility();
        updateCursorPosition(window.innerWidth / 2, window.innerHeight / 2); // Start at center
        
        // Debug logging
        console.log('[KeyPilot Early] CSS cursor applied');
      } else {
        // Retry in next tick
        setTimeout(applyCursor, 1);
      }
    };

    applyCursor();
    setupStateListener();
  }

  /**
   * Expose early cursor API for main extension
   */
  window.KEYPILOT_EARLY = {
    getCursor: () => null, // No cursor element anymore
    getPosition: () => mousePosition,
    getClickableElements: () => Array.from(earlyClickableElements),
    getPendingKeyEvents: () => [...pendingKeyEvents],
    clearPendingKeyEvents: () => { pendingKeyEvents = []; },
    updatePosition: updateCursorPosition,
    setEnabled: (enabled) => {
      isExtensionEnabled = enabled;
      updateCursorVisibility();
    },
    cleanup: () => {
      // Remove CSS cursor
      if (document.documentElement) {
        try {
          document.documentElement.classList.remove(CURSOR_HIDDEN_CLASS);
          document.documentElement.style.removeProperty(CURSOR_VAR);
        } catch {}
        document.documentElement.style.cursor = '';
      }
      if (document.body) {
        document.body.style.cursor = '';
      }
      document.removeEventListener('mousemove', handleMouseMove);
      stopEarlyKeyboardCapture();
      if (earlyObserver) {
        earlyObserver.disconnect();
      }
    }
  };

  // Check extension state before initialization
  async function init() {
    setupMainLoadedHandoffListener();
    // Inject cursor CSS immediately so `checkExtensionState()` can apply the
    // cursor at document_start without waiting for the full early init.
    // NOTE: The rules are scoped to `html.kpv2-cursor-hidden` so they are inert unless enabled.
    injectEarlyCSS();

    // Onboarding shell should appear as early as possible to avoid UI pop-in.
    // The bundled content script will adopt this DOM and hydrate it later.
    setupEarlyOnboardingStorageSync();
    await checkExtensionState();

    // Always start keyboard capture for Alt+K toggle, regardless of extension state
    startEarlyKeyboardCapture();

    if (isExtensionEnabled) {
      initEarlyInjection();
    } else {
      console.log('[KeyPilot Early] Extension is disabled, skipping early injection but keeping Alt+K capture active');
    }
  }
  
  // Start initialization
  init();

})();
